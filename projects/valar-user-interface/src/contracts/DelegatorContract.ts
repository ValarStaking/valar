/* eslint-disable */
// @ts-nocheck
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  AppStorageSchema,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "contract_create(address,address,uint64)uint64": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "delegation_terms_general": {
          "name": "DelegationTermsGeneral",
          "elements": [
            [
              "commission",
              "uint64"
            ],
            [
              "fee_round",
              "uint64"
            ],
            [
              "fee_setup",
              "uint64"
            ],
            [
              "fee_asset_id",
              "uint64"
            ],
            [
              "partner_address",
              "address"
            ],
            [
              "fee_round_partner",
              "uint64"
            ],
            [
              "fee_setup_partner",
              "uint64"
            ],
            [
              "rounds_setup",
              "uint64"
            ],
            [
              "rounds_confirm",
              "uint64"
            ]
          ]
        },
        "delegation_terms_balance": {
          "name": "DelegationTermsBalance",
          "elements": [
            [
              "stake_max",
              "uint64"
            ],
            [
              "cnt_breach_del_max",
              "uint64"
            ],
            [
              "rounds_breach",
              "uint64"
            ],
            [
              "gating_asa_list",
              "(uint64,uint64)[2]"
            ]
          ]
        }
      }
    },
    "contract_pay(txn)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "keys_confirm(address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "keys_not_confirmed()(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "keys_not_submitted()(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "key_reg_txn_info": {
          "name": "KeyRegTxnInfo",
          "elements": [
            [
              "vote_first",
              "uint64"
            ],
            [
              "vote_last",
              "uint64"
            ],
            [
              "vote_key_dilution",
              "uint64"
            ],
            [
              "vote_pk",
              "byte[32]"
            ],
            [
              "selection_pk",
              "byte[32]"
            ],
            [
              "state_proof_pk",
              "byte[64]"
            ],
            [
              "sender",
              "address"
            ]
          ]
        },
        "output": {
          "name": "EarningsDistributionAndMessage",
          "elements": [
            [
              "earnings_distribution",
              "(uint64,uint64,uint64)"
            ],
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "BreachLimitsReturn",
          "elements": [
            [
              "max_breach_reached",
              "bool"
            ],
            [
              "earnings_distribution",
              "(uint64,uint64,uint64)"
            ],
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "breach_pay()(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "breach_suspended()((uint64,uint64,uint64),address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "EarningsDistributionAndMessage",
          "elements": [
            [
              "earnings_distribution",
              "(uint64,uint64,uint64)"
            ],
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "contract_claim()(uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "EarningsDistribution",
          "elements": [
            [
              "user",
              "uint64"
            ],
            [
              "platform",
              "uint64"
            ],
            [
              "asset_id",
              "uint64"
            ]
          ]
        }
      }
    },
    "contract_expired()((uint64,uint64,uint64),address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "EarningsDistributionAndMessage",
          "elements": [
            [
              "earnings_distribution",
              "(uint64,uint64,uint64)"
            ],
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    },
    "contract_withdraw(address)(uint64,uint64,uint64)": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "EarningsDistribution",
          "elements": [
            [
              "user",
              "uint64"
            ],
            [
              "platform",
              "uint64"
            ],
            [
              "asset_id",
              "uint64"
            ]
          ]
        }
      }
    },
    "contract_delete(address)(uint64,uint64)": {
      "call_config": {
        "delete_application": "CALL"
      },
      "structs": {
        "output": {
          "name": "ContractDeleteReturn",
          "elements": [
            [
              "remaining_balance",
              "uint64"
            ],
            [
              "asset_id",
              "uint64"
            ]
          ]
        }
      }
    },
    "contract_report_expiry_soon(uint64,uint64)(address,byte[100])": {
      "call_config": {
        "no_op": "CALL"
      },
      "structs": {
        "output": {
          "name": "Message",
          "elements": [
            [
              "del_manager",
              "address"
            ],
            [
              "msg",
              "byte[100]"
            ]
          ]
        }
      }
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDExCgpzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmFwcHJvdmFsX3Byb2dyYW06CiAgICBpbnRjYmxvY2sgMCAxIDQgMTYKICAgIGJ5dGVjYmxvY2sgIkciICJzdGF0ZSIgImRlbF9tYW5hZ2VyIiAicm91bmRfZW5kIiAweDE1MWY3Yzc1ICJyb3VuZF9zdGFydCIgMHgwNSAiZGVsX2JlbmVmaWNpYXJ5IiAicm91bmRfZW5kZWQiICJyb3VuZF9jbGFpbV9sYXN0IiAiZmVlX29wZXJhdGlvbmFsIiAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiICJCIiAiY250X2JyZWFjaF9kZWwiIDB4MDMgMHgwNCAicm91bmRfYnJlYWNoX2xhc3QiICJub3RpY2Vib2FyZF9hcHBfaWQiICJ2YWxpZGF0b3JfYWRfYXBwX2lkIiAweDAwICJyb3VuZF9leHBpcnlfc29vbl9sYXN0IiAweDEwICJ2b3RlX2tleV9kaWx1dGlvbiIgInNlbF9rZXkiICJ2b3RlX2tleSIgInN0YXRlX3Byb29mX2tleSIgInRjX3NoYTI1NiIKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDIKICAgIGNhbGxzdWIgX19pbml0X18KCm1haW5fYWZ0ZXJfaWZfZWxzZUAyOgogICAgY2FsbHN1YiBfX3B1eWFfYXJjNF9yb3V0ZXJfXwogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5fX2luaXRfXygpIC0+IHZvaWQ6Cl9faW5pdF9fOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyNzgKICAgIC8vIGRlZiBfX2luaXRfXyhzZWxmKSAtPiBOb25lOgogICAgcHJvdG8gMCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4MwogICAgLy8gc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDE3IC8vICJub3RpY2Vib2FyZF9hcHBfaWQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mjg0CiAgICAvLyBzZWxmLnZhbGlkYXRvcl9hZF9hcHBfaWQgPSBVSW50NjQoMCkKICAgIGJ5dGVjIDE4IC8vICJ2YWxpZGF0b3JfYWRfYXBwX2lkIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI4NwogICAgLy8gRGVsZWdhdGlvblRlcm1zR2VuZXJhbC5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDk2KSksCiAgICBwdXNoaW50IDk2IC8vIDk2CiAgICBiemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyODgKICAgIC8vIGtleT0iRyIsCiAgICBieXRlY18wIC8vICJHIgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyODYtMjkwCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCA9IEdsb2JhbFN0YXRlKAogICAgLy8gICAgIERlbGVnYXRpb25UZXJtc0dlbmVyYWwuZnJvbV9ieXRlcyhvcC5iemVybyg5NikpLAogICAgLy8gICAgIGtleT0iRyIsCiAgICAvLyAgICAgZGVzY3JpcHRpb249IkdlbmVyYWwgZGVsZWdhdGlvbiB0ZXJtcy4iCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyOTEKICAgIC8vIHNlbGYuZmVlX29wZXJhdGlvbmFsID0gVUludDY0KDApCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI5MgogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTEgLy8gImZlZV9vcGVyYXRpb25hbF9wYXJ0bmVyIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjI5NAogICAgLy8gRGVsZWdhdGlvblRlcm1zQmFsYW5jZS5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDU2KSksCiAgICBwdXNoaW50IDU2IC8vIDU2CiAgICBiemVybwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyOTUKICAgIC8vIGtleT0iQiIsCiAgICBieXRlYyAxMiAvLyAiQiIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MjkzLTI5NwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UgPSBHbG9iYWxTdGF0ZSgKICAgIC8vICAgICBEZWxlZ2F0aW9uVGVybXNCYWxhbmNlLmZyb21fYnl0ZXMob3AuYnplcm8oNTYpKSwKICAgIC8vICAgICBrZXk9IkIiLAogICAgLy8gICAgIGRlc2NyaXB0aW9uPSJCYWxhbmNlIHJlbGF0ZWQgZGVsZWdhdGlvbiB0ZXJtcy4iCiAgICAvLyApCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToyOTkKICAgIC8vIHNlbGYuZGVsX21hbmFnZXIgPSBHbG9iYWwuemVyb19hZGRyZXNzCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzAwCiAgICAvLyBzZWxmLmRlbF9iZW5lZmljaWFyeSA9IEdsb2JhbC56ZXJvX2FkZHJlc3MKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzAyCiAgICAvLyBzZWxmLnJvdW5kX3N0YXJ0ID0gVUludDY0KDApCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDMKICAgIC8vIHNlbGYucm91bmRfZW5kID0gVUludDY0KDApCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzA0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gVUludDY0KDApCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDYKICAgIC8vIHNlbGYudm90ZV9rZXlfZGlsdXRpb24gPSBVSW50NjQoMCkKICAgIGJ5dGVjIDIyIC8vICJ2b3RlX2tleV9kaWx1dGlvbiIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDcKICAgIC8vIHNlbGYuc2VsX2tleSA9IFNlbFBrLmZyb21fYnl0ZXMob3AuYnplcm8oMzIpKQogICAgcHVzaGludCAzMiAvLyAzMgogICAgYnplcm8KICAgIGJ5dGVjIDIzIC8vICJzZWxfa2V5IgogICAgZGlnIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMwOAogICAgLy8gc2VsZi52b3RlX2tleSA9IFZvdGVQay5mcm9tX2J5dGVzKG9wLmJ6ZXJvKDMyKSkKICAgIGJ5dGVjIDI0IC8vICJ2b3RlX2tleSIKICAgIGRpZyAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMDkKICAgIC8vIHNlbGYuc3RhdGVfcHJvb2Zfa2V5ID0gU3RhdGVQcm9vZlBrLmZyb21fYnl0ZXMob3AuYnplcm8oNjQpKQogICAgcHVzaGludCA2NCAvLyA2NAogICAgYnplcm8KICAgIGJ5dGVjIDI1IC8vICJzdGF0ZV9wcm9vZl9rZXkiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMTEKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9OT05FKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAxOSAvLyAweDAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozMTMKICAgIC8vIHNlbGYudGNfc2hhMjU2ID0gU2hhMjU2LmZyb21fYnl0ZXMob3AuYnplcm8oMzIpKQogICAgYnl0ZWMgMjYgLy8gInRjX3NoYTI1NiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxNQogICAgLy8gc2VsZi5jbnRfYnJlYWNoX2RlbCA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTMgLy8gImNudF9icmVhY2hfZGVsIgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxNgogICAgLy8gc2VsZi5yb3VuZF9icmVhY2hfbGFzdCA9IFVJbnQ2NCgwKQogICAgYnl0ZWMgMTYgLy8gInJvdW5kX2JyZWFjaF9sYXN0IgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMxOAogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0ID0gVUludDY0KDApCiAgICBieXRlYyA5IC8vICJyb3VuZF9jbGFpbV9sYXN0IgogICAgaW50Y18wIC8vIDAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMyMAogICAgLy8gc2VsZi5yb3VuZF9leHBpcnlfc29vbl9sYXN0ID0gVUludDY0KDApCiAgICBieXRlYyAyMCAvLyAicm91bmRfZXhwaXJ5X3Nvb25fbGFzdCIKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5fX3B1eWFfYXJjNF9yb3V0ZXJfXygpIC0+IHVpbnQ2NDoKX19wdXlhX2FyYzRfcm91dGVyX186CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNC0xMDUKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHByb3RvIDAgMQogICAgdHhuIE51bUFwcEFyZ3MKICAgIGJ6IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2FmdGVyX2lmX2Vsc2VAMjAKICAgIHB1c2hieXRlc3MgMHhkMWJlY2NjZSAweDdkM2RiNDc0IDB4YjQ3ZWY5ZWIgMHhjYWViMWE3YiAweDI2MWJkMTk5IDB4ZmU4MTFhZTcgMHgxZjMzOTlhOCAweGMxNzczZWUwIDB4OTUxNjI0NWUgMHg5MDQ0ZTIxZiAweDI2ZjU5YTQ2IDB4Yjg4MzIyYmIgMHhmNTNiOTVjZCAweGYyZTY3OTM0IDB4ZWFmYTFlMTUgLy8gbWV0aG9kICJjb250cmFjdF9jcmVhdGUoYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCl1aW50NjQiLCBtZXRob2QgImNvbnRyYWN0X3NldHVwKGJ5dGVbMzJdLCh1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpLCh1aW50NjQsdWludDY0LHVpbnQ2NCwodWludDY0LHVpbnQ2NClbMl0pLHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJjb250cmFjdF9wYXkodHhuKXZvaWQiLCBtZXRob2QgImtleXNfY29uZmlybShhZGRyZXNzKXZvaWQiLCBtZXRob2QgImtleXNfbm90X2NvbmZpcm1lZCgpKGFkZHJlc3MsYnl0ZVsxMDBdKSIsIG1ldGhvZCAia2V5c19ub3Rfc3VibWl0dGVkKCkoYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJrZXlzX3N1Ym1pdCgodWludDY0LHVpbnQ2NCx1aW50NjQsYnl0ZVszMl0sYnl0ZVszMl0sYnl0ZVs2NF0sYWRkcmVzcykpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJicmVhY2hfbGltaXRzKCkoYm9vbCwodWludDY0LHVpbnQ2NCx1aW50NjQpLGFkZHJlc3MsYnl0ZVsxMDBdKSIsIG1ldGhvZCAiYnJlYWNoX3BheSgpKGFkZHJlc3MsYnl0ZVsxMDBdKSIsIG1ldGhvZCAiYnJlYWNoX3N1c3BlbmRlZCgpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJjb250cmFjdF9jbGFpbSgpKHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiY29udHJhY3RfZXhwaXJlZCgpKCh1aW50NjQsdWludDY0LHVpbnQ2NCksYWRkcmVzcyxieXRlWzEwMF0pIiwgbWV0aG9kICJjb250cmFjdF93aXRoZHJhdyhhZGRyZXNzKSh1aW50NjQsdWludDY0LHVpbnQ2NCkiLCBtZXRob2QgImNvbnRyYWN0X2RlbGV0ZShhZGRyZXNzKSh1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKHVpbnQ2NCx1aW50NjQpKGFkZHJlc3MsYnl0ZVsxMDBdKSIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2NyZWF0ZV9yb3V0ZUAyIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X3NldHVwX3JvdXRlQDMgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfcGF5X3JvdXRlQDQgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19jb25maXJtX3JvdXRlQDUgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDYgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3Rfc3VibWl0dGVkX3JvdXRlQDcgX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19zdWJtaXRfcm91dGVAOCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfbGltaXRzX3JvdXRlQDkgX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX3BheV9yb3V0ZUAxMCBfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfc3VzcGVuZGVkX3JvdXRlQDExIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2NsYWltX3JvdXRlQDEyIF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2V4cGlyZWRfcm91dGVAMTMgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3Rfd2l0aGRyYXdfcm91dGVAMTQgX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfZGVsZXRlX3JvdXRlQDE1IF9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X3JlcG9ydF9leHBpcnlfc29vbl9yb3V0ZUAxNgogICAgaW50Y18wIC8vIDAKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfY3JlYXRlX3JvdXRlQDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMyMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjMyMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NyZWF0ZQogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3Rfc2V0dXBfcm91dGVAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzYxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNC0xMDUKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzYxCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9zZXR1cAogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfcGF5X3JvdXRlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQyNQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDI1CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgY2FsbHN1YiBjb250cmFjdF9wYXkKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfY29uZmlybV9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0LTEwNQogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfY29uZmlybQogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fa2V5c19ub3RfY29uZmlybWVkX3JvdXRlQDY6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUwOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBrZXlzX25vdF9jb25maXJtZWQKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2tleXNfbm90X3N1Ym1pdHRlZF9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NTQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIga2V5c19ub3Rfc3VibWl0dGVkCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19rZXlzX3N1Ym1pdF9yb3V0ZUA4OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MDAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0LTEwNQogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MDAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGtleXNfc3VibWl0CiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfbGltaXRzX3JvdXRlQDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBicmVhY2hfbGltaXRzCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19icmVhY2hfcGF5X3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MTcKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgYnJlYWNoX3BheQogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fYnJlYWNoX3N1c3BlbmRlZF9yb3V0ZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Nzg3CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICBjYWxsc3ViIGJyZWFjaF9zdXNwZW5kZWQKICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2NsYWltX3JvdXRlQDEyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MzAKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGNhbGxzdWIgY29udHJhY3RfY2xhaW0KICAgIGJ5dGVjIDQgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXRzdWIKCl9fcHV5YV9hcmM0X3JvdXRlcl9fX2NvbnRyYWN0X2V4cGlyZWRfcm91dGVAMTM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk4MAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgY2FsbHN1YiBjb250cmFjdF9leHBpcmVkCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jb250cmFjdF93aXRoZHJhd19yb3V0ZUAxNDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMTgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X3dpdGhkcmF3CiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19jb250cmFjdF9kZWxldGVfcm91dGVAMTU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNTYKICAgIC8vIEBhcmM0LmFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiRGVsZXRlQXBwbGljYXRpb24iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIHB1c2hpbnQgNSAvLyBEZWxldGVBcHBsaWNhdGlvbgogICAgPT0KICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IERlbGV0ZUFwcGxpY2F0aW9uCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0LTEwNQogICAgLy8gIyAtLS0tLS0tIFNtYXJ0IGNvbnRyYWN0IC0tLS0tLS0KICAgIC8vIGNsYXNzIERlbGVnYXRvckNvbnRyYWN0KEFSQzRDb250cmFjdCwgYXZtX3ZlcnNpb249MTEpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDU2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICBjYWxsc3ViIGNvbnRyYWN0X2RlbGV0ZQogICAgYnl0ZWMgNCAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKX19wdXlhX2FyYzRfcm91dGVyX19fY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uX3JvdXRlQDE2OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTE2CiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNC0xMDUKICAgIC8vICMgLS0tLS0tLSBTbWFydCBjb250cmFjdCAtLS0tLS0tCiAgICAvLyBjbGFzcyBEZWxlZ2F0b3JDb250cmFjdChBUkM0Q29udHJhY3QsIGF2bV92ZXJzaW9uPTExKToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExNgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uCiAgICBieXRlYyA0IC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgpfX3B1eWFfYXJjNF9yb3V0ZXJfX19hZnRlcl9pZl9lbHNlQDIwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQtMTA1CiAgICAvLyAjIC0tLS0tLS0gU21hcnQgY29udHJhY3QgLS0tLS0tLQogICAgLy8gY2xhc3MgRGVsZWdhdG9yQ29udHJhY3QoQVJDNENvbnRyYWN0LCBhdm1fdmVyc2lvbj0xMSk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9jcmVhdGUoZGVsX21hbmFnZXI6IGJ5dGVzLCBkZWxfYmVuZWZpY2lhcnk6IGJ5dGVzLCBub3RpY2Vib2FyZF9hcHBfaWQ6IHVpbnQ2NCkgLT4gYnl0ZXM6CmNvbnRyYWN0X2NyZWF0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzIyLTMyOAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKGNyZWF0ZT0icmVxdWlyZSIpCiAgICAvLyBkZWYgY29udHJhY3RfY3JlYXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBkZWxfYmVuZWZpY2lhcnk6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBub3RpY2Vib2FyZF9hcHBfaWQ6IFVJbnQ2NCwKICAgIC8vICkgLT4gYXJjNC5VSW50NjQ6CiAgICBwcm90byAzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzQ5LTM1MAogICAgLy8gIyBTZXQgZ2xvYmFsIHZhcmlhYmxlcwogICAgLy8gc2VsZi5ub3RpY2Vib2FyZF9hcHBfaWQgPSBub3RpY2Vib2FyZF9hcHBfaWQKICAgIGJ5dGVjIDE3IC8vICJub3RpY2Vib2FyZF9hcHBfaWQiCiAgICBmcmFtZV9kaWcgLTEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM1MQogICAgLy8gc2VsZi52YWxpZGF0b3JfYWRfYXBwX2lkID0gR2xvYmFsLmNhbGxlcl9hcHBsaWNhdGlvbl9pZAogICAgYnl0ZWMgMTggLy8gInZhbGlkYXRvcl9hZF9hcHBfaWQiCiAgICBnbG9iYWwgQ2FsbGVyQXBwbGljYXRpb25JRAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzUzCiAgICAvLyBzZWxmLmRlbF9tYW5hZ2VyID0gZGVsX21hbmFnZXIubmF0aXZlCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGZyYW1lX2RpZyAtMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzU0CiAgICAvLyBzZWxmLmRlbF9iZW5lZmljaWFyeSA9IGRlbF9iZW5lZmljaWFyeS5uYXRpdmUKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzU2LTM1NwogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gQ1JFQVRFRAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0NSRUFURUQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIHB1c2hieXRlcyAweDAxCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozNTkKICAgIC8vIHJldHVybiBhcmM0LlVJbnQ2NChHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9pZC5pZCkKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25JRAogICAgaXRvYgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9zZXR1cCh0Y19zaGEyNTY6IGJ5dGVzLCBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWw6IGJ5dGVzLCBkZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2U6IGJ5dGVzLCByb3VuZHNfZHVyYXRpb246IHVpbnQ2NCkgLT4gdm9pZDoKY29udHJhY3Rfc2V0dXA6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM2MS0zNjgKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3Rfc2V0dXAoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB0Y19zaGEyNTY6IFNoYTI1NiwKICAgIC8vICAgICBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWw6IERlbGVnYXRpb25UZXJtc0dlbmVyYWwsCiAgICAvLyAgICAgZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlOiBEZWxlZ2F0aW9uVGVybXNCYWxhbmNlLAogICAgLy8gICAgIHJvdW5kc19kdXJhdGlvbjogVUludDY0LAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gNCAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM4OAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM4OQogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfQ1JFQVRFRCksIEVSUk9SX05PVF9TVEFURV9DUkVBVEVECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBwdXNoYnl0ZXMgMHgwMQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBDUkVBVEVELgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTozOTEKICAgIC8vIHNlbGYudGNfc2hhMjU2ID0gdGNfc2hhMjU2LmNvcHkoKQogICAgYnl0ZWMgMjYgLy8gInRjX3NoYTI1NiIKICAgIGZyYW1lX2RpZyAtNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MzkyCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZSA9IGRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC5jb3B5KCkKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBmcmFtZV9kaWcgLTMKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM5MwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UudmFsdWUgPSBkZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UuY29weSgpCiAgICBieXRlYyAxMiAvLyAiQiIKICAgIGZyYW1lX2RpZyAtMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk1CiAgICAvLyBzZWxmLnJvdW5kX3N0YXJ0ID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk2CiAgICAvLyBzZWxmLnJvdW5kX2VuZCA9IHNlbGYucm91bmRfc3RhcnQgKyByb3VuZHNfZHVyYXRpb24KICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9zdGFydCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk3CiAgICAvLyBzZWxmLnJvdW5kX2NsYWltX2xhc3QgPSBzZWxmLnJvdW5kX3N0YXJ0CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICBieXRlYyA5IC8vICJyb3VuZF9jbGFpbV9sYXN0IgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDAxCiAgICAvLyBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kLm5hdGl2ZSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDIKICAgIC8vIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDMKICAgIC8vIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfc3RhcnQsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjM5OS00MDQKICAgIC8vICMgQ2FsY3VsYXRlIG9wZXJhdGlvbmFsIGZlZQogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWwgPSBjYWxjX2ZlZV9vcGVyYXRpb25hbCgKICAgIC8vICAgICBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kLm5hdGl2ZSwKICAgIC8vICAgICByb3VuZF9lbmQ9c2VsZi5yb3VuZF9lbmQsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ9c2VsZi5yb3VuZF9zdGFydCwKICAgIC8vICkKICAgIGNhbGxzdWIgY2FsY19mZWVfb3BlcmF0aW9uYWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk5LTQwMAogICAgLy8gIyBDYWxjdWxhdGUgb3BlcmF0aW9uYWwgZmVlCiAgICAvLyBzZWxmLmZlZV9vcGVyYXRpb25hbCA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgYnl0ZWMgMTAgLy8gImZlZV9vcGVyYXRpb25hbCIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Mzk5LTQwNAogICAgLy8gIyBDYWxjdWxhdGUgb3BlcmF0aW9uYWwgZmVlCiAgICAvLyBzZWxmLmZlZV9vcGVyYXRpb25hbCA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZD1zZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmQubmF0aXZlLAogICAgLy8gICAgIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIC8vICAgICByb3VuZF9zdGFydD1zZWxmLnJvdW5kX3N0YXJ0LAogICAgLy8gKQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDA3CiAgICAvLyBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA2NCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDgKICAgIC8vIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDkKICAgIC8vIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfc3RhcnQsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQwNS00MTAKICAgIC8vICMgQ2FsY3VsYXRlIHRoZSBwYXJ0bmVyIGNvbnZlbmllbmNlIG9wZXJhdGlvbmFsIGZlZQogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZD1zZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmRfcGFydG5lci5uYXRpdmUsCiAgICAvLyAgICAgcm91bmRfZW5kPXNlbGYucm91bmRfZW5kLAogICAgLy8gICAgIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfc3RhcnQsCiAgICAvLyApCiAgICBjYWxsc3ViIGNhbGNfZmVlX29wZXJhdGlvbmFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQwNS00MDYKICAgIC8vICMgQ2FsY3VsYXRlIHRoZSBwYXJ0bmVyIGNvbnZlbmllbmNlIG9wZXJhdGlvbmFsIGZlZQogICAgLy8gc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgYnl0ZWMgMTEgLy8gImZlZV9vcGVyYXRpb25hbF9wYXJ0bmVyIgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0MDUtNDEwCiAgICAvLyAjIENhbGN1bGF0ZSB0aGUgcGFydG5lciBjb252ZW5pZW5jZSBvcGVyYXRpb25hbCBmZWUKICAgIC8vIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgPSBjYWxjX2ZlZV9vcGVyYXRpb25hbCgKICAgIC8vICAgICBmZWVfcm91bmQ9c2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlLAogICAgLy8gICAgIHJvdW5kX2VuZD1zZWxmLnJvdW5kX2VuZCwKICAgIC8vICAgICByb3VuZF9zdGFydD1zZWxmLnJvdW5kX3N0YXJ0LAogICAgLy8gKQogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDEyCiAgICAvLyBpZiBkZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwuZmVlX2Fzc2V0X2lkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBmcmFtZV9kaWcgLTMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGIhPQogICAgYnogY29udHJhY3Rfc2V0dXBfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQxMy00MTgKICAgIC8vICMgT3B0IGluIHRvIHRoZSBhc3NldAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9ZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLmZlZV9hc3NldF9pZC5uYXRpdmUsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICBhc3NldF9hbW91bnQ9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDE1CiAgICAvLyB4ZmVyX2Fzc2V0PWRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC5mZWVfYXNzZXRfaWQubmF0aXZlLAogICAgZnJhbWVfZGlnIDAKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDE2CiAgICAvLyBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDE3CiAgICAvLyBhc3NldF9hbW91bnQ9MCwKICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQxMy00MTQKICAgIC8vICMgT3B0IGluIHRvIHRoZSBhc3NldAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDEzLTQxOAogICAgLy8gIyBPcHQgaW4gdG8gdGhlIGFzc2V0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwuZmVlX2Fzc2V0X2lkLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCmNvbnRyYWN0X3NldHVwX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDIwLTQyMQogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gU0VUCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfU0VUKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgwMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDIzCiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5oZWxwZXJzLmNvbW1vbi5jYWxjX2ZlZV9vcGVyYXRpb25hbChmZWVfcm91bmQ6IHVpbnQ2NCwgcm91bmRfZW5kOiB1aW50NjQsIHJvdW5kX3N0YXJ0OiB1aW50NjQpIC0+IHVpbnQ2NDoKY2FsY19mZWVfb3BlcmF0aW9uYWw6CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6NjgwLTY4NgogICAgLy8gIyAtLS0tLS0tIEZ1bmN0aW9ucyAtLS0tLS0tCiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZDogVUludDY0LAogICAgLy8gICAgIHJvdW5kX2VuZDogVUludDY0LAogICAgLy8gICAgIHJvdW5kX3N0YXJ0OiBVSW50NjQsCiAgICAvLyApIC0+IFVJbnQ2NDoKICAgIHByb3RvIDMgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5OjcwNgogICAgLy8gcmV0dXJuIChmZWVfcm91bmQgKiAocm91bmRfZW5kIC0gcm91bmRfc3RhcnQpKSAvLyBVSW50NjQoRlJPTV9CQVNFX1RPX01JTExJX01VTFRJUExJRVIpCiAgICBmcmFtZV9kaWcgLTIKICAgIGZyYW1lX2RpZyAtMQogICAgLQogICAgZnJhbWVfZGlnIC0zCiAgICAqCiAgICBwdXNoaW50IDEwMDAgLy8gMTAwMAogICAgLwogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF9wYXkodHhuOiB1aW50NjQpIC0+IHZvaWQ6CmNvbnRyYWN0X3BheToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDI1LTQyOQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb250cmFjdF9wYXkoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICB0eG46IGd0eG4uVHJhbnNhY3Rpb24sCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAxIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDM5CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDQwCiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9TRVQpLCBFUlJPUl9OT1RfU1RBVEVfU0VUCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBwdXNoYnl0ZXMgMHgwMgogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBTRVQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ0Mi00NDMKICAgIC8vICMgQ2hlY2sgcGF5bWVudAogICAgLy8gYmFzZV9mZWUgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfc2V0dXAubmF0aXZlICsgc2VsZi5mZWVfb3BlcmF0aW9uYWwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDQ0CiAgICAvLyBwYXJ0bmVyX2ZlZSA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cF9wYXJ0bmVyLm5hdGl2ZSArIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgNzIgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ0NQogICAgLy8gYW10X2V4cGVjdGVkID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NDYKICAgIC8vIGlmIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5QYXltZW50OgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBUeXBlRW51bQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYnogY29udHJhY3RfcGF5X2Vsc2VfYm9keUAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ0NwogICAgLy8gYXNzZXJ0IHR4bi5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCBFUlJPUl9SRUNFSVZFUgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gVHJhbnNhY3Rpb24gbXVzdCBiZSB0byB0aGlzIGNvbnRyYWN0LgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NDkKICAgIC8vIGFzc2VydCBVSW50NjQoQUxHT19BU0FfSUQpID09IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9hc3NldF9pZCwgRVJST1JfQVNTRVRfSUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBiPT0KICAgIGFzc2VydCAvLyBTZW50IGFzc2V0IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ1MAogICAgLy8gYXNzZXJ0IHR4bi5hbW91bnQgPT0gYW10X2V4cGVjdGVkLCBFUlJPUl9BTU9VTlQKICAgIGZyYW1lX2RpZyAtMQogICAgZ3R4bnMgQW1vdW50CiAgICA9PQogICAgYXNzZXJ0IC8vIFNlbnQgYW1vdW50IGRvZXNuJ3QgbWF0Y2ggdGhlIGFncmVlZCBvbmUuCiAgICBiIGNvbnRyYWN0X3BheV9hZnRlcl9pZl9lbHNlQDYKCmNvbnRyYWN0X3BheV9lbHNlX2JvZHlAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDUxCiAgICAvLyBlbGlmIHR4bi50eXBlID09IFRyYW5zYWN0aW9uVHlwZS5Bc3NldFRyYW5zZmVyOgogICAgZnJhbWVfZGlnIDAKICAgIGludGNfMiAvLyBheGZlcgogICAgPT0KICAgIGFzc2VydCAvLyBUcmFuc2FjdGlvbiB0eXBlIG11c3QgYmUgZWl0aGVyIFBheW1lbnQgb3IgQXNzZXRUcmFuc2Zlci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDUyCiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X3JlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsIEVSUk9SX1JFQ0VJVkVSCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFzc2V0UmVjZWl2ZXIKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIFRyYW5zYWN0aW9uIG11c3QgYmUgdG8gdGhpcyBjb250cmFjdC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDU0CiAgICAvLyBhc3NlcnQgdHhuLnhmZXJfYXNzZXQuaWQgPT0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX2Fzc2V0X2lkLCBFUlJPUl9BU1NFVF9JRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBYZmVyQXNzZXQKICAgIGl0b2IKICAgIGI9PQogICAgYXNzZXJ0IC8vIFNlbnQgYXNzZXQgZG9lc24ndCBtYXRjaCB0aGUgYWdyZWVkIG9uZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDU1CiAgICAvLyBhc3NlcnQgdHhuLmFzc2V0X2Ftb3VudCA9PSBhbXRfZXhwZWN0ZWQsIEVSUk9SX0FNT1VOVAogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBBc3NldEFtb3VudAogICAgPT0KICAgIGFzc2VydCAvLyBTZW50IGFtb3VudCBkb2Vzbid0IG1hdGNoIHRoZSBhZ3JlZWQgb25lLgoKY29udHJhY3RfcGF5X2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDU5LTQ2MAogICAgLy8gIyBDaGVjayBpZiBkZWxfYmVuZWZpY2lhcnkgaXMgZWxpZ2libGUgYWNjb3JkaW5nIHRvIHRoZSBhZ3JlZWQgdGVybXMKICAgIC8vIGFzc2VydCBzZWxmLl9pc19lbGlnaWJsZSgpLm5hdGl2ZSwgRVJST1JfTk9UX0VMSUdJQkxFCiAgICBjYWxsc3ViIF9pc19lbGlnaWJsZQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBiZW5lZmljaWFyeSBpcyBub3QgZWxpZ2libGUgYWNjb3JkaW5nIHRvIHRoZSBhZ3JlZWQgbGltaXRzLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjItNDYzCiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBSRUFEWQogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX1JFQURZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAxNCAvLyAweDAzCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0NjUKICAgIC8vIHJldHVybgogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5faXNfZWxpZ2libGUoKSAtPiBieXRlczoKX2lzX2VsaWdpYmxlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTU3LTExNjMKICAgIC8vICMgLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0tLS0tLS0tLS0tLS0tIC0tLS0tIC0tLS0tIC0tLS0tCiAgICAvLyAjIC0tLS0tIC0tLS0tIC0tLS0tIEludGVybmFsIGZ1bmN0aW9ucyAtLS0tLSAtLS0tLSAtLS0tLQogICAgLy8gIyAtLS0tLSAtLS0tLSAtLS0tLSAtLS0tLS0tLS0tLS0tLS0tLS0gLS0tLS0gLS0tLS0gLS0tLS0KICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX2lzX2VsaWdpYmxlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IGFyYzQuQm9vbDoKICAgIHByb3RvIDAgMQogICAgaW50Y18wIC8vIDAKICAgIGR1cAogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE3NS0xMTc2CiAgICAvLyAjIENoZWNrIEFMR08gbGltaXQKICAgIC8vIGFsZ29fYmFsID0gc2VsZi5kZWxfYmVuZWZpY2lhcnkuYmFsYW5jZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfYmVuZWZpY2lhcnkgZXhpc3RzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTc3CiAgICAvLyBpc19lbGlnaWJsZSA9IGlzX2VsaWdpYmxlIGFuZCAoYWxnb19iYWwgPD0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UudmFsdWUuc3Rha2VfbWF4KQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJCIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZSBleGlzdHMKICAgIGV4dHJhY3QgMCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgc3dhcAogICAgaXRvYgogICAgYj49CiAgICBieiBfaXNfZWxpZ2libGVfYm9vbF9mYWxzZUAzCiAgICBpbnRjXzEgLy8gMQogICAgZnJhbWVfYnVyeSA1CiAgICBiIF9pc19lbGlnaWJsZV9ib29sX21lcmdlQDQKCl9pc19lbGlnaWJsZV9ib29sX2ZhbHNlQDM6CiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSA1CgpfaXNfZWxpZ2libGVfYm9vbF9tZXJnZUA0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTc5LTExODAKICAgIC8vICMgQ2hlY2sgQVNBIGxpbWl0cwogICAgLy8gYXNhX2lkX2xpc3QgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZS52YWx1ZS5nYXRpbmdfYXNhX2xpc3QuY29weSgpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTIgLy8gIkIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlIGV4aXN0cwogICAgZXh0cmFjdCAyNCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTgxCiAgICAvLyBmb3IgaWR4IGluIHVyYW5nZShhc2FfaWRfbGlzdC5sZW5ndGgpOgogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgNAoKX2lzX2VsaWdpYmxlX2Zvcl9oZWFkZXJANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE4MQogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoYXNhX2lkX2xpc3QubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA0CiAgICBwdXNoaW50IDIgLy8gMgogICAgPAogICAgYnogX2lzX2VsaWdpYmxlX2FmdGVyX2ZvckAxNwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTgyCiAgICAvLyBhc3NldF9pZCA9IGFzYV9pZF9saXN0W2lkeF0uaWQubmF0aXZlCiAgICBmcmFtZV9kaWcgNAogICAgaW50Y18zIC8vIDE2CiAgICAqCiAgICBmcmFtZV9kaWcgMAogICAgc3dhcAogICAgaW50Y18zIC8vIDE2CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGR1cAogICAgZnJhbWVfYnVyeSAzCiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExODMKICAgIC8vIGlmIGFzc2V0X2lkICE9IEFMR09fQVNBX0lEOgogICAgYnogX2lzX2VsaWdpYmxlX2FmdGVyX2lmX2Vsc2VAMTUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE4NQogICAgLy8gaWYgc2VsZi5kZWxfYmVuZWZpY2lhcnkuaXNfb3B0ZWRfaW4oYXNzZXQpOgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDcgLy8gImRlbF9iZW5lZmljaWFyeSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfYmVuZWZpY2lhcnkgZXhpc3RzCiAgICBmcmFtZV9kaWcgMwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJ6IF9pc19lbGlnaWJsZV9lbHNlX2JvZHlAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTg2CiAgICAvLyBhc2FfYmFsID0gYXNzZXQuYmFsYW5jZShzZWxmLmRlbF9iZW5lZmljaWFyeSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJkZWxfYmVuZWZpY2lhcnkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2JlbmVmaWNpYXJ5IGV4aXN0cwogICAgZnJhbWVfZGlnIDMKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgc3dhcAogICAgZnJhbWVfYnVyeSAyCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICBiIF9pc19lbGlnaWJsZV9hZnRlcl9pZl9lbHNlQDEwCgpfaXNfZWxpZ2libGVfZWxzZV9ib2R5QDk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExODgKICAgIC8vIGFzYV9iYWwgPSBVSW50NjQoMCkKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDIKCl9pc19lbGlnaWJsZV9hZnRlcl9pZl9lbHNlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTg5CiAgICAvLyBpc19lbGlnaWJsZSA9IGlzX2VsaWdpYmxlIGFuZCAoYXNhX2JhbCA+PSBhc2FfaWRfbGlzdFtpZHhdLm1pbi5uYXRpdmUpCiAgICBmcmFtZV9kaWcgNQogICAgYnogX2lzX2VsaWdpYmxlX2Jvb2xfZmFsc2VAMTMKICAgIGZyYW1lX2RpZyAxCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2RpZyAyCiAgICA8PQogICAgYnogX2lzX2VsaWdpYmxlX2Jvb2xfZmFsc2VAMTMKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDUKICAgIGIgX2lzX2VsaWdpYmxlX2Jvb2xfbWVyZ2VAMTQKCl9pc19lbGlnaWJsZV9ib29sX2ZhbHNlQDEzOgogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2J1cnkgNQoKX2lzX2VsaWdpYmxlX2Jvb2xfbWVyZ2VAMTQ6CiAgICBmcmFtZV9kaWcgNQogICAgZnJhbWVfYnVyeSA2CgpfaXNfZWxpZ2libGVfYWZ0ZXJfaWZfZWxzZUAxNToKICAgIGZyYW1lX2RpZyA2CiAgICBmcmFtZV9idXJ5IDUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE4MQogICAgLy8gZm9yIGlkeCBpbiB1cmFuZ2UoYXNhX2lkX2xpc3QubGVuZ3RoKToKICAgIGZyYW1lX2RpZyA0CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA0CiAgICBiIF9pc19lbGlnaWJsZV9mb3JfaGVhZGVyQDUKCl9pc19lbGlnaWJsZV9hZnRlcl9mb3JAMTc6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExOTEKICAgIC8vIHJldHVybiBhcmM0LkJvb2woaXNfZWxpZ2libGUpCiAgICBieXRlYyAxOSAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDUKICAgIHNldGJpdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmtleXNfY29uZmlybShkZWxfbWFuYWdlcjogYnl0ZXMpIC0+IHZvaWQ6CmtleXNfY29uZmlybToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDY3LTQ3MQogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX2NvbmZpcm0oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBkZWxfbWFuYWdlcjogYXJjNC5BZGRyZXNzLAogICAgLy8gKSAtPiBOb25lOgogICAgcHJvdG8gMSAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4MQogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4MgogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfU1VCTUlUVEVEKSwgRVJST1JfTk9UX1NUQVRFX1NVQk1JVFRFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTUgLy8gMHgwNAogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBTVUJNSVRURUQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4NAogICAgLy8gYXNzZXJ0IGRlbF9tYW5hZ2VyID09IHNlbGYuZGVsX21hbmFnZXIsIEVSUk9SX05PVF9NQU5BR0VSCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgYXBwcm92ZWQgYnkgZGVsZWdhdG9yIG1hbmFnZXIuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4Ni00ODcKICAgIC8vICMgQ2hlY2sgaWYgY29uZmlybWF0aW9uIHdhcyBkb25lIGluIHRpbWUKICAgIC8vIGFzc2VydCBHbG9iYWwucm91bmQgPD0gKAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OAogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OQogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDgwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OC00ODkKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ5MAogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX2NvbmZpcm0ubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDg4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ4OC00OTAKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDg2LTQ5MAogICAgLy8gIyBDaGVjayBpZiBjb25maXJtYXRpb24gd2FzIGRvbmUgaW4gdGltZQogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA8PSAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX2NvbmZpcm0ubmF0aXZlCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0ODYtNDkxCiAgICAvLyAjIENoZWNrIGlmIGNvbmZpcm1hdGlvbiB3YXMgZG9uZSBpbiB0aW1lCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kIDw9ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgIC8vICksIEVSUk9SX0tFWV9DT05GSVJNX1RPT19MQVRFCiAgICBhc3NlcnQgLy8gS2V5IGNvbmZpcm1hdGlvbiB3YXMgZG9uZSB0b28gbGF0ZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NDkzLTQ5NQogICAgLy8gIyBDaGVjayB0aGF0IGJlbmVmaWNpYXJ5IGFjY291bnQgaGFzIGBBY2N0SW5jZW50aXZlRWxpZ2libGVgIGZsYWcgc2V0IHRvIHRydWUgYmVjYXVzZSBvdGhlcndpc2UKICAgIC8vICMgdGhlIGRlbGVnYXRvcidzIGNvbnRyYWN0IHdvdWxkIHJlcG9ydCBicmVhY2hfc3VzcGVuc2lvbiByaWdodCBhd2F5LgogICAgLy8gYWNjdF9pbmNlbnRpdmVfZWxpZ2libGVfcmF3ID0gb3AuQWNjdFBhcmFtc0dldC5hY2N0X2luY2VudGl2ZV9lbGlnaWJsZShzZWxmLmRlbF9iZW5lZmljaWFyeSkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA3IC8vICJkZWxfYmVuZWZpY2lhcnkiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX2JlbmVmaWNpYXJ5IGV4aXN0cwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RJbmNlbnRpdmVFbGlnaWJsZQogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjQ5NwogICAgLy8gYXNzZXJ0IGFjY3RfaW5jZW50aXZlX2VsaWdpYmxlLCBFUlJPUl9BQ0NPVU5UX0hBU19OT1RfUkVHSVNURVJFRF9GT1JfU1VTUEVOU0lPTl9UUkFDS0lORwogICAgYXNzZXJ0IC8vIE11c3Qgb3B0LWluIHRvIGNvbnNlbnN1cyBzdXNwZW5zaW9uIHRyYWNraW5nLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo0OTktNTAwCiAgICAvLyAjIFNldCB0aGUgbGFzdCBicmVhY2ggcm91bmQgdG8gY3VycmVudCBvbmUKICAgIC8vIHNlbGYucm91bmRfYnJlYWNoX2xhc3QgPSBHbG9iYWwucm91bmQKICAgIGJ5dGVjIDE2IC8vICJyb3VuZF9icmVhY2hfbGFzdCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTAxLTUwMgogICAgLy8gIyBSZXNldCB0aGUgbnVtYmVyIG9mIGJyZWFjaGVzCiAgICAvLyBzZWxmLmNudF9icmVhY2hfZGVsID0gVUludDY0KDApCiAgICBieXRlYyAxMyAvLyAiY250X2JyZWFjaF9kZWwiCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTA0LTUwNQogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gTElWRQogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0xJVkUpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTA3CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Qua2V5c19ub3RfY29uZmlybWVkKCkgLT4gYnl0ZXM6CmtleXNfbm90X2NvbmZpcm1lZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTA5LTUxMgogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX25vdF9jb25maXJtZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MjQKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MjUKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1NVQk1JVFRFRCksIEVSUk9SX05PVF9TVEFURV9TVUJNSVRURUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE1IC8vIDB4MDQKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gU1VCTUlUVEVELgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MjctNTI4CiAgICAvLyAjIENoZWNrIGlmIHRpbWUgZm9yIGNvbmZpcm1hdGlvbiBoYXMgcGFzc2VkCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kID4gKAogICAgZ2xvYmFsIFJvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUyOQogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNSAvLyAicm91bmRfc3RhcnQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfc3RhcnQgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUzMAogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDgwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUyOS01MzAKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUzMQogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX2NvbmZpcm0ubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDg4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUyOS01MzEKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZSArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTI3LTUzMQogICAgLy8gIyBDaGVjayBpZiB0aW1lIGZvciBjb25maXJtYXRpb24gaGFzIHBhc3NlZAogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA+ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTI3LTUzMgogICAgLy8gIyBDaGVjayBpZiB0aW1lIGZvciBjb25maXJtYXRpb24gaGFzIHBhc3NlZAogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA+ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfY29uZmlybS5uYXRpdmUKICAgIC8vICksIEVSUk9SX1JFUE9SVF9OT1RfQ09ORklSTUVEX1RPT19FQVJMWQogICAgYXNzZXJ0IC8vIFJlcG9ydCBrZXlzIGFzIG5vdCBjb25maXJtZWQgY2FuIGJlIGRvbmUgb25seSBhZnRlciBlbm91Z2ggcm91bmRzIGhhdmUgcGFzc2VkLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MzQtNTM1CiAgICAvLyAjIElmIHBvc3NpYmxlLCByZXR1cm4gdGhlIG9wZXJhdGlvbmFsIGZlZXMgdG8gdGhlIGRlbGVnYXRvciBtYW5hZ2VyCiAgICAvLyBmZWVfYXNzZXQgPSBBc3NldChzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQubmF0aXZlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1MzYKICAgIC8vIGFtdF9yZXR1cm4gPSBzZWxmLmZlZV9vcGVyYXRpb25hbCArIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjUzNy01NDAKICAgIC8vIHNlbGYuX3RyeV9yZXR1cm5fZmVlKAogICAgLy8gICAgIGZlZV9hc3NldD1mZWVfYXNzZXQsCiAgICAvLyAgICAgYW10X3JldHVybj1hbXRfcmV0dXJuLAogICAgLy8gKQogICAgY2FsbHN1YiBfdHJ5X3JldHVybl9mZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTQyLTU0MwogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gRU5ERURfTk9UX0NPTkZJUk1FRAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0VOREVEX05PVF9DT05GSVJNRUQpCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIHB1c2hieXRlcyAweDExCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NDUtNTQ2CiAgICAvLyAjIE1hcmsgZW5kIG9mIGNvbnRyYWN0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTUwCiAgICAvLyBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU0OAogICAgLy8gbXNnID0gTm90aWZpY2F0aW9uTWVzc2FnZS5mcm9tX2J5dGVzKE1TR19DT1JFX0tFWVNfTk9UX0NPTkZJUk1FRCkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA1OTZmNzUyMDY4NjE3NjY1MjA2ZTZmNzQyMDYzNmY2ZTY2Njk3MjZkNjU2NDIwNzQ2ODY1MjA2ZTZmNjQ2NTIwNzQ2ODYxNzQyMDc3NjE3MzIwNzA3MjY1NzA2MTcyNjU2NDIwNjY2ZjcyMjA3OTZmNzUyZTIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU0OS01NTIKICAgIC8vIHJldHVybiBNZXNzYWdlKAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5fdHJ5X3JldHVybl9mZWUoZmVlX2Fzc2V0OiB1aW50NjQsIGFtdF9yZXR1cm46IHVpbnQ2NCkgLT4gdm9pZDoKX3RyeV9yZXR1cm5fZmVlOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTkzLTExOTgKICAgIC8vIEBzdWJyb3V0aW5lCiAgICAvLyBkZWYgX3RyeV9yZXR1cm5fZmVlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZmVlX2Fzc2V0OiBBc3NldCwKICAgIC8vICAgICBhbXRfcmV0dXJuOiBVSW50NjQsCiAgICAvLyApIC0+IE5vbmU6CiAgICBwcm90byAyIDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTIxMQogICAgLy8gaWYgZmVlX2Fzc2V0LmlkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBmcmFtZV9kaWcgLTIKICAgIGJ6IF90cnlfcmV0dXJuX2ZlZV9lbHNlX2JvZHlAOQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjEyCiAgICAvLyBpZiBzZWxmLmRlbF9tYW5hZ2VyLmlzX29wdGVkX2luKGZlZV9hc3NldCk6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBieiBfdHJ5X3JldHVybl9mZWVfYWZ0ZXJfaWZfZWxzZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjEzCiAgICAvLyBpZiBub3QgZmVlX2Fzc2V0LmZyb3plbihzZWxmLmRlbF9tYW5hZ2VyKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRGcm96ZW4KICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGJueiBfdHJ5X3JldHVybl9mZWVfYWZ0ZXJfaWZfZWxzZUAxMwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjE0CiAgICAvLyBhc3NldF9iYWxhbmNlID0gZmVlX2Fzc2V0LmJhbGFuY2Uoc2VsZi5kZWxfbWFuYWdlcikKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIGZyYW1lX2RpZyAtMgogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMTUKICAgIC8vIGlmIGFzc2V0X2JhbGFuY2UgPj0gYW10X3JldHVybjoKICAgIGZyYW1lX2RpZyAtMQogICAgPj0KICAgIGJ6IF90cnlfcmV0dXJuX2ZlZV9hZnRlcl9pZl9lbHNlQDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMTYtMTIyMAogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9ZmVlX2Fzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFtdF9yZXR1cm4sCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMTgKICAgIC8vIGFzc2V0X3JlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIC0yCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjE2CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjE2LTEyMjAKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWZlZV9hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hbXRfcmV0dXJuLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIGIgX3RyeV9yZXR1cm5fZmVlX2FmdGVyX2lmX2Vsc2VAMTMKCl90cnlfcmV0dXJuX2ZlZV9lbHNlX2JvZHlAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTIyMgogICAgLy8gaWYgb3AuYmFsYW5jZShzZWxmLmRlbF9tYW5hZ2VyKSA+PSBHbG9iYWwubWluX2JhbGFuY2U6CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBiYWxhbmNlCiAgICBnbG9iYWwgTWluQmFsYW5jZQogICAgPj0KICAgIGJ6IF90cnlfcmV0dXJuX2ZlZV9hZnRlcl9pZl9lbHNlQDEzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMjMtMTIyNgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYW1vdW50PWFtdF9yZXR1cm4sCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMjQKICAgIC8vIHJlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEyMjMKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjIzLTEyMjYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD1hbXRfcmV0dXJuLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCl90cnlfcmV0dXJuX2ZlZV9hZnRlcl9pZl9lbHNlQDEzOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMjI4CiAgICAvLyByZXR1cm4KICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Qua2V5c19ub3Rfc3VibWl0dGVkKCkgLT4gYnl0ZXM6CmtleXNfbm90X3N1Ym1pdHRlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTU0LTU1NwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX25vdF9zdWJtaXR0ZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NjkKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzAKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1JFQURZKSwgRVJST1JfTk9UX1NUQVRFX1JFQURZCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAxNCAvLyAweDAzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIFJFQURZLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzItNTczCiAgICAvLyAjIENoZWNrIGlmIHRpbWUgZm9yIHN1Ym1pc3Npb24gaGFzIHBhc3NlZAogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA+ICgKICAgIGdsb2JhbCBSb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzQKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX3N0YXJ0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1NzUKICAgIC8vIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLnJvdW5kc19zZXR1cC5uYXRpdmUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgODAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTc0LTU3NQogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU3Mi01NzUKICAgIC8vICMgQ2hlY2sgaWYgdGltZSBmb3Igc3VibWlzc2lvbiBoYXMgcGFzc2VkCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kID4gKAogICAgLy8gICAgIHNlbGYucm91bmRfc3RhcnQgKwogICAgLy8gICAgIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLnJvdW5kc19zZXR1cC5uYXRpdmUKICAgID4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTcyLTU3NgogICAgLy8gIyBDaGVjayBpZiB0aW1lIGZvciBzdWJtaXNzaW9uIGhhcyBwYXNzZWQKICAgIC8vIGFzc2VydCBHbG9iYWwucm91bmQgPiAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZQogICAgLy8gKSwgRVJST1JfUkVQT1JUX05PVF9TVUJNSVRURURfVE9PX0VBUkxZCiAgICBhc3NlcnQgLy8gUmVwb3J0IGtleXMgYXMgbm90IHN1Ym1pdHRlZCBjYW4gYmUgZG9uZSBvbmx5IGFmdGVyIGVub3VnaCByb3VuZHMgaGF2ZSBwYXNzZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU3OC01NzkKICAgIC8vICMgSWYgcG9zc2libGUsIHJldHVybiB0aGUgc3VtIG9mIHRoZSBzZXR1cCBhbmQgb3BlcmF0aW9uYWwgZmVlcyB0byB0aGUgZGVsZWdhdG9yIG1hbmFnZXIKICAgIC8vIGZlZV9hc3NldCA9IEFzc2V0KHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9hc3NldF9pZC5uYXRpdmUpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDI0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU4MAogICAgLy8gYmFzZV9mZWUgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfc2V0dXAubmF0aXZlICsgc2VsZi5mZWVfb3BlcmF0aW9uYWwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTgxCiAgICAvLyBwYXJ0bmVyX2ZlZSA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cF9wYXJ0bmVyLm5hdGl2ZSArIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgNzIgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU4MgogICAgLy8gYW10X3JldHVybiA9IGJhc2VfZmVlICsgcGFydG5lcl9mZWUKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTgzLTU4NgogICAgLy8gc2VsZi5fdHJ5X3JldHVybl9mZWUoCiAgICAvLyAgICAgZmVlX2Fzc2V0PWZlZV9hc3NldCwKICAgIC8vICAgICBhbXRfcmV0dXJuPWFtdF9yZXR1cm4sCiAgICAvLyApCiAgICBjYWxsc3ViIF90cnlfcmV0dXJuX2ZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1ODgtNTg5CiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBFTkRFRF9OT1RfU1VCTUlUVEVECiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfRU5ERURfTk9UX1NVQk1JVFRFRCkKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYnl0ZWMgMjEgLy8gMHgxMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NTkxLTU5MgogICAgLy8gIyBNYXJrIGVuZCBvZiBjb250cmFjdAogICAgLy8gc2VsZi5yb3VuZF9lbmRlZCA9IEdsb2JhbC5yb3VuZAogICAgYnl0ZWMgOCAvLyAicm91bmRfZW5kZWQiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjU5NgogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1OTQKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9LRVlTX05PVF9TVUJNSVRURUQpCiAgICBwdXNoYnl0ZXMgMHg0ZDY1NzM3MzYxNjc2NTIwNjY3MjZmNmQyMDU2NjE2YzYxNzIzYTIwNGU2ZjY0NjUyMDcyNzU2ZTZlNjU3MjIwNjg2MTczMjA3NTZlNjY2ZjcyNzQ3NTZlNjE3NDY1NmM3OTIwNmU2Zjc0MjA3MDcyNjU3MDYxNzI2NTY0MjA2MTIwNmU2ZjY0NjUyMDY2NmY3MjIwNzk2Zjc1MmUyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo1OTUtNTk4CiAgICAvLyByZXR1cm4gTWVzc2FnZSgKICAgIC8vICAgICBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICAvLyAgICAgbXNnPW1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3Qua2V5c19zdWJtaXQoa2V5X3JlZ190eG5faW5mbzogYnl0ZXMpIC0+IGJ5dGVzOgprZXlzX3N1Ym1pdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjAwLTYwNAogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBrZXlzX3N1Ym1pdCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGtleV9yZWdfdHhuX2luZm8gOiBLZXlSZWdUeG5JbmZvLAogICAgLy8gKSAtPiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2U6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjI1CiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjI2CiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSksIEVSUk9SX05PVF9TVEFURV9SRUFEWQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTQgLy8gMHgwMwogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBSRUFEWS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjI4LTYyOQogICAgLy8gIyBTYW5pdHkgY2hlY2sgb24gc3VibWl0dGVkIGtleSBpbmZvcm1hdGlvbgogICAgLy8gYXNzZXJ0IHNlbGYuZGVsX2JlbmVmaWNpYXJ5ID09IGtleV9yZWdfdHhuX2luZm8uc2VuZGVyLCBFUlJPUl9LRVlfQkVORUZJQ0lBUllfTUlTTUFUQ0gKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAxNTIgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiZGVsX2JlbmVmaWNpYXJ5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9iZW5lZmljaWFyeSBleGlzdHMKICAgID09CiAgICBhc3NlcnQgLy8gS2V5IGJlbmVmaWNpYXJ5IGRvZXMgbm90IG1hdGNoLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MzAKICAgIC8vIGFzc2VydCBzZWxmLnJvdW5kX3N0YXJ0ID09IGtleV9yZWdfdHhuX2luZm8udm90ZV9maXJzdCwgRVJST1JfVk9URV9GSVJTVF9ST1VORF9NSVNNQVRDSAogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA1IC8vICJyb3VuZF9zdGFydCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9zdGFydCBleGlzdHMKICAgIGl0b2IKICAgIGI9PQogICAgYXNzZXJ0IC8vIFZvdGUgZmlyc3Qgcm91bmQgZG9lcyBub3QgbWF0Y2ggY29udHJhY3Qgc3RhcnQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzMQogICAgLy8gYXNzZXJ0IHNlbGYucm91bmRfZW5kID09IGtleV9yZWdfdHhuX2luZm8udm90ZV9sYXN0LCBFUlJPUl9WT1RFX0xBU1RfUk9VTkRfTUlTTUFUQ0gKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2VuZCBleGlzdHMKICAgIGl0b2IKICAgIGI9PQogICAgYXNzZXJ0IC8vIFZvdGUgbGFzdCByb3VuZCBkb2VzIG5vdCBtYXRjaCBjb250cmFjdCBlbmQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzMy02MzQKICAgIC8vICMgU3RvcmUgc3VibWl0dGVkIGtleSBpbmZvcm1hdGlvbgogICAgLy8gc2VsZi52b3RlX2tleV9kaWx1dGlvbiA9IGtleV9yZWdfdHhuX2luZm8udm90ZV9rZXlfZGlsdXRpb24ubmF0aXZlCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGJ5dGVjIDIyIC8vICJ2b3RlX2tleV9kaWx1dGlvbiIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzNQogICAgLy8gc2VsZi52b3RlX2tleSA9IGtleV9yZWdfdHhuX2luZm8udm90ZV9way5jb3B5KCkKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAyNCAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ5dGVjIDI0IC8vICJ2b3RlX2tleSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzNgogICAgLy8gc2VsZi5zZWxfa2V5ID0ga2V5X3JlZ190eG5faW5mby5zZWxlY3Rpb25fcGsuY29weSgpCiAgICBmcmFtZV9kaWcgLTEKICAgIGV4dHJhY3QgNTYgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBieXRlYyAyMyAvLyAic2VsX2tleSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzNwogICAgLy8gc2VsZi5zdGF0ZV9wcm9vZl9rZXkgPSBrZXlfcmVnX3R4bl9pbmZvLnN0YXRlX3Byb29mX3BrLmNvcHkoKQogICAgZnJhbWVfZGlnIC0xCiAgICBleHRyYWN0IDg4IDY0IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnl0ZWMgMjUgLy8gInN0YXRlX3Byb29mX2tleSIKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzOS02NDAKICAgIC8vICMgQ2hlY2sgaWYgc3VibWlzc2lvbiB3YXMgZG9uZSBpbiB0aW1lCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kIDw9ICgKICAgIGdsb2JhbCBSb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDEKICAgIC8vIHNlbGYucm91bmRfc3RhcnQgKwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDUgLy8gInJvdW5kX3N0YXJ0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX3N0YXJ0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDIKICAgIC8vIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLnJvdW5kc19zZXR1cC5uYXRpdmUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgODAgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjQxLTY0MgogICAgLy8gc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlCiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjYzOS02NDIKICAgIC8vICMgQ2hlY2sgaWYgc3VibWlzc2lvbiB3YXMgZG9uZSBpbiB0aW1lCiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kIDw9ICgKICAgIC8vICAgICBzZWxmLnJvdW5kX3N0YXJ0ICsKICAgIC8vICAgICBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5yb3VuZHNfc2V0dXAubmF0aXZlCiAgICA8PQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2MzktNjQzCiAgICAvLyAjIENoZWNrIGlmIHN1Ym1pc3Npb24gd2FzIGRvbmUgaW4gdGltZQogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCA8PSAoCiAgICAvLyAgICAgc2VsZi5yb3VuZF9zdGFydCArCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucm91bmRzX3NldHVwLm5hdGl2ZQogICAgLy8gKSwgRVJST1JfS0VZX1NVQk1JVF9UT09fTEFURQogICAgYXNzZXJ0IC8vIEtleSBzdWJtaXNzaW9uIHdhcyBkb25lIHRvbyBsYXRlLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDcKICAgIC8vIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cC5uYXRpdmUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY0OAogICAgLy8gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3NldHVwX3BhcnRuZXIubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA3MiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NDUtNjQ5CiAgICAvLyAjIERpc3RyaWJ1dGUgZWFybmluZ3MgZnJvbSB0aGUgc2V0dXAgZmVlCiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBzZWxmLl9kaXN0cmlidXRlX2Vhcm5pbmdzKAogICAgLy8gICAgIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cC5uYXRpdmUsCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3NldHVwX3BhcnRuZXIubmF0aXZlLAogICAgLy8gKQogICAgY2FsbHN1YiBfZGlzdHJpYnV0ZV9lYXJuaW5ncwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NTEtNjUyCiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBMSVZFCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfU1VCTUlUVEVEKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBieXRlYyAxNSAvLyAweDA0CiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NTcKICAgIC8vIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjU1LTY1OQogICAgLy8gcmV0dXJuIEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZSgKICAgIC8vICAgICBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2NTQKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9LRVlTX1NVQk1JVCkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA0ZTZmNjQ2NTIwNjg2MTczMjA2MjY1NjU2ZTIwNzA3MjY1NzA2MTcyNjU2NDIwNjY2ZjcyMjA3OTZmNzUyMDc0NmYyMDczNzQ2MTZiNjUyZTIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY1NS02NTkKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2UoCiAgICAvLyAgICAgZWFybmluZ3NfZGlzdHJpYnV0aW9uID0gZWFybmluZ3NfZGlzdHJpYnV0aW9uLmNvcHkoKSwKICAgIC8vICAgICBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICAvLyAgICAgbXNnPW1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuX2Rpc3RyaWJ1dGVfZWFybmluZ3MoYW1vdW50OiB1aW50NjQsIGFtb3VudF9wYXJ0bmVyOiB1aW50NjQpIC0+IGJ5dGVzOgpfZGlzdHJpYnV0ZV9lYXJuaW5nczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODc2LTg4MQogICAgLy8gQHN1YnJvdXRpbmUKICAgIC8vIGRlZiBfZGlzdHJpYnV0ZV9lYXJuaW5ncygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGFtb3VudDogVUludDY0LAogICAgLy8gICAgIGFtb3VudF9wYXJ0bmVyOiBVSW50NjQsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkwMQogICAgLy8gYXNzZXQgPSBBc3NldChzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQubmF0aXZlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkwMgogICAgLy8gdmFsX2FwcCA9IEFwcGxpY2F0aW9uKHNlbGYudmFsaWRhdG9yX2FkX2FwcF9pZCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxOCAvLyAidmFsaWRhdG9yX2FkX2FwcF9pZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi52YWxpZGF0b3JfYWRfYXBwX2lkIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MDMKICAgIC8vIHBsYV9hcHAgPSBBcHBsaWNhdGlvbihzZWxmLm5vdGljZWJvYXJkX2FwcF9pZCkKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxNyAvLyAibm90aWNlYm9hcmRfYXBwX2lkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLm5vdGljZWJvYXJkX2FwcF9pZCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTA1CiAgICAvLyBwYXJ0bmVyID0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUucGFydG5lcl9hZGRyZXNzLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAzMiAzMiAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTEwCiAgICAvLyBjb21taXNzaW9uPXNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmNvbW1pc3Npb24ubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkwNy05MTIKICAgIC8vICMgQ2FsY3VsYXRlIGVhcm5pbmdzCiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBjYWxjX2Vhcm5pbmdzKAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgY29tbWlzc2lvbj1zZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5jb21taXNzaW9uLm5hdGl2ZSwKICAgIC8vICAgICBhc3NldF9pZD1hc3NldC5pZCwKICAgIC8vICkKICAgIGZyYW1lX2RpZyAtMgogICAgc3dhcAogICAgZGlnIDIKICAgIGNhbGxzdWIgY2FsY19lYXJuaW5ncwogICAgc3dhcAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MTQKICAgIC8vIGlmIGFzc2V0LmlkICE9IFVJbnQ2NChBTEdPX0FTQV9JRCk6CiAgICBieiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19lbHNlX2JvZHlAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTE1CiAgICAvLyBhc3NlcnQgYXNzZXQuYmFsYW5jZShHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzKSA+PSBhbW91bnQgKyBhbW91bnRfcGFydG5lciwgXAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgICsKICAgID49CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkxNS05MTYKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpID49IGFtb3VudCArIGFtb3VudF9wYXJ0bmVyLCBcCiAgICAvLyAgICAgRVJST1JfSU5TVUZGSUNJRU5UX0JBTEFOQ0UKICAgIGFzc2VydCAvLyBFYXJuaW5ncyBjYW5ub3QgYmUgcGFpZCBiZWNhdXNlIERlbGVnYXRvckNvbnRyYWN0IGhhcyBpbnN1ZmZpY2llbnQgYW1vdW50LgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MTgKICAgIC8vIGFzc2VydCBub3QgYXNzZXQuZnJvemVuKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpLCBcCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgZGlnIDEKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0RnJvemVuCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICAhCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkxOC05MTkKICAgIC8vIGFzc2VydCBub3QgYXNzZXQuZnJvemVuKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpLCBcCiAgICAvLyAgICAgRVJST1JfQkFMQU5DRV9GUk9aRU4KICAgIGFzc2VydCAvLyBFYXJuaW5ncyBjYW5ub3QgYmUgcGFpZCBiZWNhdXNlIERlbGVnYXRvckNvbnRyYWN0IGhhcyB0aGUgYXNzZXQgZnJvemVuLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjEtOTIyCiAgICAvLyAjIFNlbmQgdmFsaWRhdG9yIGVhcm5pbmdzIHRvIFZhbGlkYXRvckFkIGlmIGl0IGNhbiBhY2NlcHQgdGhlbQogICAgLy8gaWYgdmFsX2FwcC5hZGRyZXNzLmlzX29wdGVkX2luKGFzc2V0KToKICAgIGZyYW1lX2RpZyAxCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBzd2FwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGJ1cnkgMQogICAgYnogX2Rpc3RyaWJ1dGVfZWFybmluZ3NfYWZ0ZXJfaWZfZWxzZUA2CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkyMwogICAgLy8gaWYgbm90IGFzc2V0LmZyb3plbih2YWxfYXBwLmFkZHJlc3MpOgogICAgZnJhbWVfZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEZyb3plbgogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgYm56IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VANgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjQtOTI4CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj12YWxfYXBwLmFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi51c2VyLm5hdGl2ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTI2CiAgICAvLyBhc3NldF9yZWNlaXZlcj12YWxfYXBwLmFkZHJlc3MsCiAgICBmcmFtZV9kaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjcKICAgIC8vIGFzc2V0X2Ftb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24udXNlci5uYXRpdmUsCiAgICBmcmFtZV9kaWcgNAogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBpdHhuX2ZpZWxkIEFzc2V0UmVjZWl2ZXIKICAgIGZyYW1lX2RpZyAwCiAgICBpdHhuX2ZpZWxkIFhmZXJBc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MjQKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIGludGNfMiAvLyBheGZlcgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkyNC05MjgKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXZhbF9hcHAuYWRkcmVzcywKICAgIC8vICAgICBhc3NldF9hbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCl9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTMwLTkzMQogICAgLy8gIyBTZW5kIHBsYXRmb3JtIGVhcm5pbmdzIHRvIE5vdGljZWJvYXJkIGlmIGl0IGNhbiBhY2NlcHQgdGhlbQogICAgLy8gaWYgcGxhX2FwcC5hZGRyZXNzLmlzX29wdGVkX2luKGFzc2V0KToKICAgIGZyYW1lX2RpZyAyCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBmcmFtZV9kaWcgMAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBidXJ5IDEKICAgIGJ6IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMTEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTMyCiAgICAvLyBpZiBub3QgYXNzZXQuZnJvemVuKHBsYV9hcHAuYWRkcmVzcyk6CiAgICBmcmFtZV9kaWcgMgogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgZnJhbWVfZGlnIDAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0RnJvemVuCiAgICBhc3NlcnQgLy8gYWNjb3VudCBvcHRlZCBpbnRvIGFzc2V0CiAgICBibnogX2Rpc3RyaWJ1dGVfZWFybmluZ3NfYWZ0ZXJfaWZfZWxzZUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5MzMtOTM3CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wbGFfYXBwLmFkZHJlc3MsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5wbGF0Zm9ybS5uYXRpdmUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzNQogICAgLy8gYXNzZXRfcmVjZWl2ZXI9cGxhX2FwcC5hZGRyZXNzLAogICAgZnJhbWVfZGlnIDIKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTM2CiAgICAvLyBhc3NldF9hbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZSwKICAgIGZyYW1lX2RpZyA0CiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGl0eG5fZmllbGQgQXNzZXRBbW91bnQKICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgZnJhbWVfZGlnIDAKICAgIGl0eG5fZmllbGQgWGZlckFzc2V0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzMwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTMzLTkzNwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgLy8gICAgIHhmZXJfYXNzZXQ9YXNzZXQsCiAgICAvLyAgICAgYXNzZXRfcmVjZWl2ZXI9cGxhX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24ucGxhdGZvcm0ubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKCl9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMTE6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjkzOS05NDAKICAgIC8vICMgU2VuZCBwYXJ0bmVyIGVhcm5pbmdzIHRvIHBhcnRuZXJfYWRkcmVzcyBpZiBpdCBpcyBub24temVybwogICAgLy8gaWYgcGFydG5lciAhPSBHbG9iYWwuemVyb19hZGRyZXNzOgogICAgZnJhbWVfZGlnIDMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJ6IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMjcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTQxLTk0MgogICAgLy8gIyBTZW5kIHRoZSBlYXJuaW5ncyBpZiB0aGUgcGFydG5lcl9hZGRyZXNzIGNhbiBhY2NlcHQgdGhlbQogICAgLy8gaWYgcGFydG5lci5pc19vcHRlZF9pbihhc3NldCk6CiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfZGlnIDAKICAgIGFzc2V0X2hvbGRpbmdfZ2V0IEFzc2V0QmFsYW5jZQogICAgYnVyeSAxCiAgICBieiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk0MwogICAgLy8gaWYgbm90IGFzc2V0LmZyb3plbihwYXJ0bmVyKToKICAgIGZyYW1lX2RpZyAzCiAgICBmcmFtZV9kaWcgMAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRGcm96ZW4KICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGJueiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk0NC05NDgKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXBhcnRuZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWFtb3VudF9wYXJ0bmVyLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgZnJhbWVfZGlnIC0xCiAgICBpdHhuX2ZpZWxkIEFzc2V0QW1vdW50CiAgICBmcmFtZV9kaWcgMwogICAgaXR4bl9maWVsZCBBc3NldFJlY2VpdmVyCiAgICBmcmFtZV9kaWcgMAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTQ0CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICBpbnRjXzIgLy8gYXhmZXIKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NDQtOTQ4CiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1wYXJ0bmVyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1hbW91bnRfcGFydG5lciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICBiIF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMjcKCl9kaXN0cmlidXRlX2Vhcm5pbmdzX2Vsc2VfYm9keUAxOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTUxCiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0QmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1MgogICAgLy8gR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQogICAgYXNzZXJ0IC8vIGFjY291bnQgZnVuZGVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1MS05NTIKICAgIC8vIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZSAtCiAgICAvLyBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1MwogICAgLy8gKSA+PSBhbW91bnQgKyBhbW91bnRfcGFydG5lciwgXAogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTUxLTk1MwogICAgLy8gICAgIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MuYmFsYW5jZSAtCiAgICAvLyAgICAgR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcy5taW5fYmFsYW5jZQogICAgLy8gKSA+PSBhbW91bnQgKyBhbW91bnRfcGFydG5lciwgXAogICAgPj0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTUwLTk1NAogICAgLy8gYXNzZXJ0ICgKICAgIC8vICAgICBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLQogICAgLy8gICAgIEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MubWluX2JhbGFuY2UKICAgIC8vICkgPj0gYW1vdW50ICsgYW1vdW50X3BhcnRuZXIsIFwKICAgIC8vICAgICBFUlJPUl9JTlNVRkZJQ0lFTlRfQUxHTwogICAgYXNzZXJ0IC8vIEVhcm5pbmdzIGNhbm5vdCBiZSBwYWlkIGJlY2F1c2UgRGVsZWdhdG9yQ29udHJhY3QgaGFzIGluc3VmZmljaWVudCBBTEdPLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NTctOTYxCiAgICAvLyAjIFNlbmQgdmFsaWRhdG9yIGVhcm5pbmdzIHRvIFZhbGlkYXRvckFkCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9dmFsX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24udXNlci5uYXRpdmUsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk1OQogICAgLy8gcmVjZWl2ZXI9dmFsX2FwcC5hZGRyZXNzLAogICAgZnJhbWVfZGlnIDEKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTYwCiAgICAvLyBhbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlLAogICAgZnJhbWVfZGlnIDQKICAgIGR1cAogICAgY292ZXIgMgogICAgZXh0cmFjdCAwIDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NTctOTU4CiAgICAvLyAjIFNlbmQgdmFsaWRhdG9yIGVhcm5pbmdzIHRvIFZhbGlkYXRvckFkCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTU3LTk2MQogICAgLy8gIyBTZW5kIHZhbGlkYXRvciBlYXJuaW5ncyB0byBWYWxpZGF0b3JBZAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXZhbF9hcHAuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnVzZXIubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTYzLTk2NwogICAgLy8gIyBTZW5kIHBsYXRmb3JtIGVhcm5pbmdzIHRvIE5vdGljZWJvYXJkCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9cGxhX2FwcC5hZGRyZXNzLAogICAgLy8gICAgIGFtb3VudD1lYXJuaW5nc19kaXN0cmlidXRpb24ucGxhdGZvcm0ubmF0aXZlLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NjUKICAgIC8vIHJlY2VpdmVyPXBsYV9hcHAuYWRkcmVzcywKICAgIGZyYW1lX2RpZyAyCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2NgogICAgLy8gYW1vdW50PWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5wbGF0Zm9ybS5uYXRpdmUsCiAgICBzd2FwCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2My05NjQKICAgIC8vICMgU2VuZCBwbGF0Zm9ybSBlYXJuaW5ncyB0byBOb3RpY2Vib2FyZAogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2My05NjcKICAgIC8vICMgU2VuZCBwbGF0Zm9ybSBlYXJuaW5ncyB0byBOb3RpY2Vib2FyZAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXBsYV9hcHAuYWRkcmVzcywKICAgIC8vICAgICBhbW91bnQ9ZWFybmluZ3NfZGlzdHJpYnV0aW9uLnBsYXRmb3JtLm5hdGl2ZSwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk2OS05NzAKICAgIC8vICMgU2VuZCBwYXJ0bmVyIGVhcm5pbmdzIHRvIHBhcnRuZXJfYWRkcmVzcyBpZiBpdCBpcyBub24temVybwogICAgLy8gaWYgcGFydG5lciAhPSBHbG9iYWwuemVyb19hZGRyZXNzOgogICAgZnJhbWVfZGlnIDMKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGJ6IF9kaXN0cmlidXRlX2Vhcm5pbmdzX2FmdGVyX2lmX2Vsc2VAMjcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTcxLTk3MgogICAgLy8gIyBUcnkgc2VuZGluZyBwYXJ0bmVyIGVhcm5pbmdzIHRvIHBhcnRuZXJfYWRkcmVzcwogICAgLy8gaWYgb3AuYmFsYW5jZShwYXJ0bmVyKSA+PSBHbG9iYWwubWluX2JhbGFuY2U6CiAgICBmcmFtZV9kaWcgMwogICAgYmFsYW5jZQogICAgZ2xvYmFsIE1pbkJhbGFuY2UKICAgID49CiAgICBieiBfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk3My05NzYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wYXJ0bmVyLAogICAgLy8gICAgIGFtb3VudD1hbW91bnRfcGFydG5lciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIGZyYW1lX2RpZyAtMQogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGZyYW1lX2RpZyAzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk3MwogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojk3My05NzYKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1wYXJ0bmVyLAogICAgLy8gICAgIGFtb3VudD1hbW91bnRfcGFydG5lciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CgpfZGlzdHJpYnV0ZV9lYXJuaW5nc19hZnRlcl9pZl9lbHNlQDI3OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5NzgKICAgIC8vIHJldHVybiBlYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpCiAgICBmcmFtZV9kaWcgNAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuaGVscGVycy5jb21tb24uY2FsY19lYXJuaW5ncyhhbW91bnQ6IHVpbnQ2NCwgY29tbWlzc2lvbjogdWludDY0LCBhc3NldF9pZDogdWludDY0KSAtPiBieXRlczoKY2FsY19lYXJuaW5nczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weTo3MzQtNzM5CiAgICAvLyBAc3Vicm91dGluZQogICAgLy8gZGVmIGNhbGNfZWFybmluZ3MoCiAgICAvLyAgICAgYW1vdW50OiBVSW50NjQsCiAgICAvLyAgICAgY29tbWlzc2lvbjogVUludDY0LAogICAgLy8gICAgIGFzc2V0X2lkOiBVSW50NjQsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uOgogICAgcHJvdG8gMyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6NzU5CiAgICAvLyB0bXAgPSBvcC5tdWx3KGFtb3VudCwgY29tbWlzc2lvbikKICAgIGZyYW1lX2RpZyAtMwogICAgZnJhbWVfZGlnIC0yCiAgICBtdWx3CiAgICAvLyBzbWFydF9jb250cmFjdHMvaGVscGVycy9jb21tb24ucHk6NzYwCiAgICAvLyBwbGF0X2Vhcm4gPSBvcC5kaXZ3KHRtcFswXSwgdG1wWzFdLCBVSW50NjQoQ09NTUlTU0lPTl9NQVgpKQogICAgcHVzaGludCAxMDAwMDAwIC8vIDEwMDAwMDAKICAgIGRpdncKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weTo3NjEKICAgIC8vIHVzZXJfZWFybiA9IGFtb3VudCAtIHBsYXRfZWFybgogICAgZnJhbWVfZGlnIC0zCiAgICBkaWcgMQogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc2NAogICAgLy8gdXNlcj1hcmM0LlVJbnQ2NCh1c2VyX2Vhcm4pLAogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc2NQogICAgLy8gcGxhdGZvcm09YXJjNC5VSW50NjQocGxhdF9lYXJuKSwKICAgIHN3YXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9oZWxwZXJzL2NvbW1vbi5weTo3NjYKICAgIC8vIGFzc2V0X2lkPWFyYzQuVUludDY0KGFzc2V0X2lkKSwKICAgIGZyYW1lX2RpZyAtMQogICAgaXRvYgogICAgLy8gc21hcnRfY29udHJhY3RzL2hlbHBlcnMvY29tbW9uLnB5Ojc2My03NjcKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbigKICAgIC8vICAgICB1c2VyPWFyYzQuVUludDY0KHVzZXJfZWFybiksCiAgICAvLyAgICAgcGxhdGZvcm09YXJjNC5VSW50NjQocGxhdF9lYXJuKSwKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyApCiAgICBjb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5icmVhY2hfbGltaXRzKCkgLT4gYnl0ZXM6CmJyZWFjaF9saW1pdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY2MS02NjQKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgYnJlYWNoX2xpbWl0cygKICAgIC8vICAgICBzZWxmLAogICAgLy8gKSAtPiBCcmVhY2hMaW1pdHNSZXR1cm46CiAgICBwcm90byAwIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjgyCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NjgzCiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKSwgRVJST1JfTk9UX1NUQVRFX0xJVkUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2ODUKICAgIC8vIGFzc2VydCBzZWxmLnJvdW5kX2VuZCA+IEdsb2JhbC5yb3VuZCwgRVJST1JfQUxSRUFEWV9FWFBJUkVECiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2VuZCBleGlzdHMKICAgIGdsb2JhbCBSb3VuZAogICAgPgogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgd2hlbiB0aGUgY29udHJhY3QgaGFzIGFscmVhZHkgZXhwaXJlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Njg3CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9icmVhY2hfbGFzdCArIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlLnZhbHVlLnJvdW5kc19icmVhY2gubmF0aXZlIDwgR2xvYmFsLnJvdW5kLCBcCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMTYgLy8gInJvdW5kX2JyZWFjaF9sYXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2JyZWFjaF9sYXN0IGV4aXN0cwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJCIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZSBleGlzdHMKICAgIGV4dHJhY3QgMTYgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgICsKICAgIGdsb2JhbCBSb3VuZAogICAgPAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2ODctNjg4CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9icmVhY2hfbGFzdCArIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19iYWxhbmNlLnZhbHVlLnJvdW5kc19icmVhY2gubmF0aXZlIDwgR2xvYmFsLnJvdW5kLCBcCiAgICAvLyAgICAgRVJST1JfTElNSVRfQlJFQUNIX1RPT19FQVJMWQogICAgYXNzZXJ0IC8vIE5vdCBlbm91Z2ggcm91bmRzIGhhdmUgcGFzc2VkIHNpbmNlIGxhc3QgbGltaXQgYnJlYWNoIGV2ZW50LgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo2OTAKICAgIC8vIGFzc2VydCBub3Qgc2VsZi5faXNfZWxpZ2libGUoKS5uYXRpdmUsIEVSUk9SX0lTX1NUSUxMX0VMSUdJQkxFCiAgICBjYWxsc3ViIF9pc19lbGlnaWJsZQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgIQogICAgYXNzZXJ0IC8vIERlbGVnYXRvciBiZW5lZmljaWFyeSBpcyBzdGlsbCBlbGlnaWJsZSBhY2NvcmRpbmcgdG8gdGhlIGFncmVlZCBsaW1pdHMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY5Mi02OTMKICAgIC8vICMgVXBkYXRlIGxpbWl0IGJyZWFjaCBldmVudCBjb3VudGVyCiAgICAvLyBzZWxmLmNudF9icmVhY2hfZGVsICs9IDEKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMyAvLyAiY250X2JyZWFjaF9kZWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuY250X2JyZWFjaF9kZWwgZXhpc3RzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnl0ZWMgMTMgLy8gImNudF9icmVhY2hfZGVsIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Njk0CiAgICAvLyBzZWxmLnJvdW5kX2JyZWFjaF9sYXN0ID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyAxNiAvLyAicm91bmRfYnJlYWNoX2xhc3QiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY5Ni02OTcKICAgIC8vICMgQ2xhaW0gZWFybmluZ3MgdXAgdG8gdGhpcyByb3VuZAogICAgLy8gZWFybmluZ3NfZGlzdHJpYnV0aW9uID0gc2VsZi5jb250cmFjdF9jbGFpbSgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NsYWltCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjY5OQogICAgLy8gbWF4X2JyZWFjaF9yZWFjaGVkID0gRmFsc2UKICAgIGludGNfMCAvLyAwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjcwMAogICAgLy8gbXNnID0gTm90aWZpY2F0aW9uTWVzc2FnZS5mcm9tX2J5dGVzKE1TR19DT1JFX0JSRUFDSF9MSU1JVFNfRVJST1IpCiAgICBwdXNoYnl0ZXMgMHg0ZDY1NzM3MzYxNjc2NTIwNjY3MjZmNmQyMDU2NjE2YzYxNzIzYTIwNTk2Zjc1NzIyMDYyNjE2YzYxNmU2MzY1MjA2OTczMjA2Zjc1NzQ3MzY5NjQ2NTIwNzQ2ODY1MjA2YzY5NmQ2OTc0NzMyMDYxNjc3MjY1NjU2NDIwNzc2OTc0NjgyMDc0Njg2NTIwNmU2ZjY0NjUyMDcyNzU2ZTZlNjU3MjJlMjA0MzZmNzI3MjY1NjM3NDIwNjk3NDIxMjAyMDIwMjAyMAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MDEKICAgIC8vIGlmIHNlbGYuY250X2JyZWFjaF9kZWwgPj0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2JhbGFuY2UudmFsdWUuY250X2JyZWFjaF9kZWxfbWF4OgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEyIC8vICJCIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfYmFsYW5jZSBleGlzdHMKICAgIGV4dHJhY3QgOCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEzIC8vICJjbnRfYnJlYWNoX2RlbCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5jbnRfYnJlYWNoX2RlbCBleGlzdHMKICAgIGl0b2IKICAgIGI8PQogICAgYnogYnJlYWNoX2xpbWl0c19hZnRlcl9pZl9lbHNlQDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzAyLTcwMwogICAgLy8gIyBDaGFuZ2Ugc3RhdGUgdG8gRU5ERURfTElNSVRTCiAgICAvLyBzZWxmLnN0YXRlID0gQnl0ZXMoU1RBVEVfRU5ERURfTElNSVRTKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxMgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzA0LTcwNQogICAgLy8gIyBNYXJrIGVuZCBvZiBjb250cmFjdAogICAgLy8gc2VsZi5yb3VuZF9lbmRlZCA9IEdsb2JhbC5yb3VuZAogICAgYnl0ZWMgOCAvLyAicm91bmRfZW5kZWQiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjcwNi03MDcKICAgIC8vICMgTWFyayB0aGF0IG1heGltdW0gbnVtYmVyIG9mIGJyZWFjaGVzIGhhcyBiZWVuIHJlYWNoZWQKICAgIC8vIG1heF9icmVhY2hfcmVhY2hlZCA9IFRydWUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzA4CiAgICAvLyBtc2cgPSBOb3RpZmljYXRpb25NZXNzYWdlLmZyb21fYnl0ZXMoTVNHX0NPUkVfQlJFQUNIX0xJTUlUU19FTkQpCiAgICBwdXNoYnl0ZXMgMHg0ZDY1NzM3MzYxNjc2NTIwNjY3MjZmNmQyMDU2NjE2YzYxNzIzYTIwNTk2Zjc1NzIyMDYzNmY2ZTc0NzI2MTYzNzQyMDY4NjE3MzIwNjU2ZTY0NjU2NDIwNjI2NTYzNjE3NTczNjUyMDc5NmY3NTIwNjI3MjY1NjE2MzY4NjU2NDIwNzQ2ODY1MjA3NDY1NzI2ZDczMjA3NDZmNmYyMDZkNjE2ZTc5MjA3NDY5NmQ2NTczMmUyMDIwMjAyMDIwMjAyMDIwMjAyMAogICAgZnJhbWVfYnVyeSAyCgpicmVhY2hfbGltaXRzX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzExCiAgICAvLyBtYXhfYnJlYWNoX3JlYWNoZWQgPSBhcmM0LkJvb2wobWF4X2JyZWFjaF9yZWFjaGVkKSwKICAgIGJ5dGVjIDE5IC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9kaWcgMQogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjcxMwogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MTAtNzE1CiAgICAvLyByZXR1cm4gQnJlYWNoTGltaXRzUmV0dXJuKAogICAgLy8gICAgIG1heF9icmVhY2hfcmVhY2hlZCA9IGFyYzQuQm9vbChtYXhfYnJlYWNoX3JlYWNoZWQpLAogICAgLy8gICAgIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbj1lYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIHN3YXAKICAgIGZyYW1lX2RpZyAwCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIDIKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X2NsYWltKCkgLT4gYnl0ZXM6CmNvbnRyYWN0X2NsYWltOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MzAtODMzCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X2NsYWltKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg0NwogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg0OAogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSksIEVSUk9SX05PVF9TVEFURV9MSVZFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODUwCiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9jbGFpbV9sYXN0IDwgR2xvYmFsLnJvdW5kLCBFUlJPUl9PUEVSQVRJT05fRkVFX0FMUkVBRFlfQ0xBSU1FRF9BVF9ST1VORAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfY2xhaW1fbGFzdCBleGlzdHMKICAgIGdsb2JhbCBSb3VuZAogICAgPAogICAgYXNzZXJ0IC8vIE9wZXJhdGlvbmFsIGZlZSBoYXMgYWxyZWFkeSBiZWVuIGNsYWltZWQgdXAgdG8gdGhpcyByb3VuZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODUyCiAgICAvLyBpZiBHbG9iYWwucm91bmQgPiBzZWxmLnJvdW5kX2VuZDoKICAgIGdsb2JhbCBSb3VuZAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICA+CiAgICBieiBjb250cmFjdF9jbGFpbV9lbHNlX2JvZHlAMgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4NTMKICAgIC8vIHJvdW5kX2NsYWltX3RvID0gc2VsZi5yb3VuZF9lbmQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgYiBjb250cmFjdF9jbGFpbV9hZnRlcl9pZl9lbHNlQDMKCmNvbnRyYWN0X2NsYWltX2Vsc2VfYm9keUAyOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4NTUKICAgIC8vIHJvdW5kX2NsYWltX3RvID0gR2xvYmFsLnJvdW5kCiAgICBnbG9iYWwgUm91bmQKCmNvbnRyYWN0X2NsYWltX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODU4CiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmQubmF0aXZlLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA4IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg2MAogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfY2xhaW1fbGFzdCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODU3LTg2MQogICAgLy8gZmVlX29wZXJhdGlvbmFsX2Vhcm5lZCA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9yb3VuZC5uYXRpdmUsCiAgICAvLyAgICAgcm91bmRfY2xhaW1fdG8sCiAgICAvLyAgICAgc2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgLy8gKQogICAgZGlnIDIKICAgIHN3YXAKICAgIGNhbGxzdWIgY2FsY19mZWVfb3BlcmF0aW9uYWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODYzCiAgICAvLyBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmRfcGFydG5lci5uYXRpdmUsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDY0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg2NQogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfY2xhaW1fbGFzdCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODYyLTg2NgogICAgLy8gZmVlX29wZXJhdGlvbmFsX2Vhcm5lZF9wYXJ0bmVyID0gY2FsY19mZWVfb3BlcmF0aW9uYWwoCiAgICAvLyAgICAgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlLAogICAgLy8gICAgIHJvdW5kX2NsYWltX3RvLAogICAgLy8gICAgIHNlbGYucm91bmRfY2xhaW1fbGFzdCwKICAgIC8vICkKICAgIGRpZyAzCiAgICBzd2FwCiAgICBjYWxsc3ViIGNhbGNfZmVlX29wZXJhdGlvbmFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg2Ny04NzAKICAgIC8vIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbiA9IHNlbGYuX2Rpc3RyaWJ1dGVfZWFybmluZ3MoCiAgICAvLyAgICAgZmVlX29wZXJhdGlvbmFsX2Vhcm5lZCwKICAgIC8vICAgICBmZWVfb3BlcmF0aW9uYWxfZWFybmVkX3BhcnRuZXIsCiAgICAvLyApCiAgICBjYWxsc3ViIF9kaXN0cmlidXRlX2Vhcm5pbmdzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg3MgogICAgLy8gc2VsZi5yb3VuZF9jbGFpbV9sYXN0ID0gcm91bmRfY2xhaW1fdG8KICAgIGJ5dGVjIDkgLy8gInJvdW5kX2NsYWltX2xhc3QiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojg3NAogICAgLy8gcmV0dXJuIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuYnJlYWNoX3BheSgpIC0+IGJ5dGVzOgpicmVhY2hfcGF5OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MTctNzIwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGJyZWFjaF9wYXkoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgcHVzaGJ5dGVzICIiCiAgICBkdXBuIDQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzMzCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzM0CiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKSBvciBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1NVQk1JVFRFRCkgb3Igc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9SRUFEWSksIEVSUk9SX05PVF9TVEFURV9MSVZFX09SX1NVQk1JVFRFRF9PUl9SRUFEWSAgIyBub3FhOiBFNTAxCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBibnogYnJlYWNoX3BheV9ib29sX3RydWVAMwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgMTUgLy8gMHgwNAogICAgPT0KICAgIGJueiBicmVhY2hfcGF5X2Jvb2xfdHJ1ZUAzCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAxNCAvLyAweDAzCiAgICA9PQogICAgYnogYnJlYWNoX3BheV9ib29sX2ZhbHNlQDQKCmJyZWFjaF9wYXlfYm9vbF90cnVlQDM6CiAgICBpbnRjXzEgLy8gMQogICAgYiBicmVhY2hfcGF5X2Jvb2xfbWVyZ2VANQoKYnJlYWNoX3BheV9ib29sX2ZhbHNlQDQ6CiAgICBpbnRjXzAgLy8gMAoKYnJlYWNoX3BheV9ib29sX21lcmdlQDU6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjczNAogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSkgb3Igc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9TVUJNSVRURUQpIG9yIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfUkVBRFkpLCBFUlJPUl9OT1RfU1RBVEVfTElWRV9PUl9TVUJNSVRURURfT1JfUkVBRFkgICMgbm9xYTogRTUwMQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUgb3IgU1VCTUlUVEVEIG9yIFJFQURZLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MzYKICAgIC8vIGFzc2VydCBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQgIT0gVUludDY0KEFMR09fQVNBX0lEKSwgRVJST1JfQUxHT19JU19QRVJNSVNTSU9OTEVTUwogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGIhPQogICAgYXNzZXJ0IC8vIEFMR08gY2Fubm90IGJlIGZyb3plbiBvciBjbGF3ZWQgYmFjay4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzM4CiAgICAvLyBmZWVfcm91bmQgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfcm91bmQubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGZyYW1lX2J1cnkgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3MzkKICAgIC8vIGZlZV9yb3VuZF9wYXJ0bmVyID0gc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwudmFsdWUuZmVlX3JvdW5kX3BhcnRuZXIubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDY0IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9idXJ5IDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQwCiAgICAvLyBmZWVfc2V0dXAgPSBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfc2V0dXAubmF0aXZlCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMCAvLyAiRyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxlZ2F0aW9uX3Rlcm1zX2dlbmVyYWwgZXhpc3RzCiAgICBleHRyYWN0IDE2IDggLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBidG9pCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQxCiAgICAvLyBmZWVfc2V0dXBfcGFydG5lciA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9zZXR1cF9wYXJ0bmVyLm5hdGl2ZQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCA3MiA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZnJhbWVfYnVyeSA0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0MwogICAgLy8gYXNzZXQgPSBBc3NldChzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbC52YWx1ZS5mZWVfYXNzZXRfaWQubmF0aXZlKQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzAgLy8gIkciCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsIGV4aXN0cwogICAgZXh0cmFjdCAyNCA4IC8vIG9uIGVycm9yOiBJbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgYnRvaQogICAgZHVwCiAgICBmcmFtZV9idXJ5IDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQ0CiAgICAvLyBpZiBhc3NldC5mcm96ZW4oR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcyk6CiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgc3dhcAogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRGcm96ZW4KICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgIGJueiBicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTkKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQ3CiAgICAvLyBpZiBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX1JFQURZKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE0IC8vIDB4MDMKICAgID09CiAgICBieiBicmVhY2hfcGF5X2Vsc2VfYm9keUA5CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc0OAogICAgLy8gYmFzZV9mZWUgPSBmZWVfc2V0dXAgKyBzZWxmLmZlZV9vcGVyYXRpb25hbAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDEwIC8vICJmZWVfb3BlcmF0aW9uYWwiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsIGV4aXN0cwogICAgZnJhbWVfZGlnIDMKICAgICsKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzQ5CiAgICAvLyBwYXJ0bmVyX2ZlZSA9IGZlZV9zZXR1cF9wYXJ0bmVyICsgc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lcgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjIDExIC8vICJmZWVfb3BlcmF0aW9uYWxfcGFydG5lciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5mZWVfb3BlcmF0aW9uYWxfcGFydG5lciBleGlzdHMKICAgIGZyYW1lX2RpZyA0CiAgICArCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc1MAogICAgLy8gYW10ID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTEKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpIDwgYW10LCBFUlJPUl9FTk9VR0hfRlVORFNfRk9SX1NFVFVQX0FORF9PUEVSQVRJT05BTF9GRUUgICMgbm9xYTogRTUwMQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgID4KICAgIGFzc2VydCAvLyBDb250cmFjdCBoYXMgc3VmZmljaWVudCBmdW5kcyB0byBwYXkgdGhlIHNldHVwIGFuZCBvcGVyYXRpb25hbCBmZWUuCiAgICBiIGJyZWFjaF9wYXlfYWZ0ZXJfaWZfZWxzZUAxOQoKYnJlYWNoX3BheV9lbHNlX2JvZHlAOToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzUyCiAgICAvLyBlbGlmIHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfU1VCTUlUVEVEKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDE1IC8vIDB4MDQKICAgID09CiAgICBieiBicmVhY2hfcGF5X2Vsc2VfYm9keUAxMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTMKICAgIC8vIGJhc2VfZmVlID0gc2VsZi5mZWVfb3BlcmF0aW9uYWwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMCAvLyAiZmVlX29wZXJhdGlvbmFsIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmZlZV9vcGVyYXRpb25hbCBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzU0CiAgICAvLyBwYXJ0bmVyX2ZlZSA9IHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyAxMSAvLyAiZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZmVlX29wZXJhdGlvbmFsX3BhcnRuZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc1NQogICAgLy8gYW10ID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTYKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpIDwgYW10LCBFUlJPUl9FTk9VR0hfRlVORFNfRk9SX09QRVJBVElPTkFMX0ZFRQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgID4KICAgIGFzc2VydCAvLyBDb250cmFjdCBoYXMgc3VmZmljaWVudCBmdW5kcyB0byBwYXkgdGhlIGZ1bGwgb3BlcmF0aW9uYWwgZmVlLgogICAgYiBicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTkKCmJyZWFjaF9wYXlfZWxzZV9ib2R5QDExOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTcKICAgIC8vIGVsaWYgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKToKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgPT0KICAgIGJ6IGJyZWFjaF9wYXlfYWZ0ZXJfaWZfZWxzZUAxOQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NTgKICAgIC8vIGlmIEdsb2JhbC5yb3VuZCA8IHNlbGYucm91bmRfZW5kOgogICAgZ2xvYmFsIFJvdW5kCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMyAvLyAicm91bmRfZW5kIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2VuZCBleGlzdHMKICAgIDwKICAgIGJ6IGJyZWFjaF9wYXlfZWxzZV9ib2R5QDE0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc1OQogICAgLy8gdG1wX3IgPSBHbG9iYWwucm91bmQKICAgIGdsb2JhbCBSb3VuZAogICAgYiBicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTUKCmJyZWFjaF9wYXlfZWxzZV9ib2R5QDE0OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NjEKICAgIC8vIHRtcF9yID0gc2VsZi5yb3VuZF9lbmQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwoKYnJlYWNoX3BheV9hZnRlcl9pZl9lbHNlQDE1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NjYKICAgIC8vIHJvdW5kX3N0YXJ0PXNlbGYucm91bmRfY2xhaW1fbGFzdCwKICAgIGludGNfMCAvLyAwCiAgICBieXRlYyA5IC8vICJyb3VuZF9jbGFpbV9sYXN0IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnJvdW5kX2NsYWltX2xhc3QgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc2My03NjcKICAgIC8vIGJhc2VfZmVlID0gY2FsY19mZWVfb3BlcmF0aW9uYWwoCiAgICAvLyAgICAgZmVlX3JvdW5kPWZlZV9yb3VuZCwKICAgIC8vICAgICByb3VuZF9lbmQ9dG1wX3IsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ9c2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgLy8gKQogICAgZnJhbWVfZGlnIDEKICAgIGRpZyAyCiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgY2FsY19mZWVfb3BlcmF0aW9uYWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzcxCiAgICAvLyByb3VuZF9zdGFydD1zZWxmLnJvdW5kX2NsYWltX2xhc3QsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgOSAvLyAicm91bmRfY2xhaW1fbGFzdCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9jbGFpbV9sYXN0IGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NjgtNzcyCiAgICAvLyBwYXJ0bmVyX2ZlZSA9IGNhbGNfZmVlX29wZXJhdGlvbmFsKAogICAgLy8gICAgIGZlZV9yb3VuZD1mZWVfcm91bmRfcGFydG5lciwKICAgIC8vICAgICByb3VuZF9lbmQ9dG1wX3IsCiAgICAvLyAgICAgcm91bmRfc3RhcnQ9c2VsZi5yb3VuZF9jbGFpbV9sYXN0LAogICAgLy8gKQogICAgZnJhbWVfZGlnIDIKICAgIHVuY292ZXIgMwogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIGNhbGNfZmVlX29wZXJhdGlvbmFsCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc3MwogICAgLy8gYW10ID0gYmFzZV9mZWUgKyBwYXJ0bmVyX2ZlZQogICAgKwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3NzQKICAgIC8vIGFzc2VydCBhc3NldC5iYWxhbmNlKEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MpIDwgYW10LCBFUlJPUl9FTk9VR0hfRlVORFNfRk9SX0VBUk5FRF9PUEVSQVRJT05BTF9GRUUgICMgbm9xYTogRTUwMQogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIGZyYW1lX2RpZyAwCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IG9wdGVkIGludG8gYXNzZXQKICAgID4KICAgIGFzc2VydCAvLyBDb250cmFjdCBoYXMgc3VmZmljaWVudCBmdW5kcyB0byBwYXkgdGhlIGVhcm5lZCBvcGVyYXRpb25hbCBmZWUuCgpicmVhY2hfcGF5X2FmdGVyX2lmX2Vsc2VAMTk6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc3Ni03NzcKICAgIC8vICMgQ2hhbmdlIHN0YXRlIHRvIEVOREVEX0NBTk5PVF9QQVkKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9FTkRFRF9DQU5OT1RfUEFZKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxNgogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6Nzc4LTc3OQogICAgLy8gIyBNYXJrIGVuZCBvZiBjb250cmFjdAogICAgLy8gc2VsZi5yb3VuZF9lbmRlZCA9IEdsb2JhbC5yb3VuZAogICAgYnl0ZWMgOCAvLyAicm91bmRfZW5kZWQiCiAgICBnbG9iYWwgUm91bmQKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5Ojc4MwogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3ODEKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9CUkVBQ0hfUEFZKQogICAgcHVzaGJ5dGVzIDB4NGQ2NTczNzM2MTY3NjUyMDY2NzI2ZjZkMjA1NjYxNmM2MTcyM2EyMDU0Njg2NTcyNjUyMDY5NzMyMDYxNmUyMDY5NzM3Mzc1NjUyMDc3Njk3NDY4MjA3OTZmNzU3MjIwNzA2MTc5NmQ2NTZlNzQyMDc0NmYyMDc0Njg2NTIwNmU2ZjY0NjUyMDcyNzU2ZTZlNjU3MjJlMjA1OTZmNzUyMDY0NmY2ZTI3NzQyMDczNzQ2MTZiNjUyMDYxNmU3OTZkNmY3MjY1MmUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6NzgyLTc4NQogICAgLy8gcmV0dXJuIE1lc3NhZ2UoCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuYnJlYWNoX3N1c3BlbmRlZCgpIC0+IGJ5dGVzOgpicmVhY2hfc3VzcGVuZGVkOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo3ODctNzkwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGJyZWFjaF9zdXNwZW5kZWQoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICkgLT4gRWFybmluZ3NEaXN0cmlidXRpb25BbmRNZXNzYWdlOgogICAgcHJvdG8gMCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgwNgogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgwNwogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSksIEVSUk9SX05PVF9TVEFURV9MSVZFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODA5CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9lbmQgPiBHbG9iYWwucm91bmQsIEVSUk9SX0FMUkVBRFlfRVhQSVJFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICBnbG9iYWwgUm91bmQKICAgID4KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbnRyYWN0IGhhcyBhbHJlYWR5IGV4cGlyZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgxMS04MTIKICAgIC8vICMgQ29uZmlybSB0aGF0IGFjY291bnQgd2FzIHN1c3BlbmRlZCBiYXNlZCBvbiBgQWNjdEluY2VudGl2ZUVsaWdpYmxlYCBwYXJhbWV0ZXIKICAgIC8vIGFjY3RfaW5jZW50aXZlX2VsaWdpYmxlX3JhdyA9IG9wLkFjY3RQYXJhbXNHZXQuYWNjdF9pbmNlbnRpdmVfZWxpZ2libGUoc2VsZi5kZWxfYmVuZWZpY2lhcnkpCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgNyAvLyAiZGVsX2JlbmVmaWNpYXJ5IgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9iZW5lZmljaWFyeSBleGlzdHMKICAgIGFjY3RfcGFyYW1zX2dldCBBY2N0SW5jZW50aXZlRWxpZ2libGUKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MTQKICAgIC8vIGFzc2VydCBub3QgYWNjdF9pbmNlbnRpdmVfZWxpZ2libGUsIEVSUk9SX0FDQ09VTlRfSEFTX05PVF9CRUVOX1NVU1BFTkRFRAogICAgIQogICAgYXNzZXJ0IC8vIEFjY291bnQgaXMgc3RpbGwgcGFydGljaXBhdGluZyBpbiBjb25zZW5zdXMuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgxNi04MTcKICAgIC8vICMgQ2xhaW0gZWFybmluZ3MgdXAgdG8gdGhpcyByb3VuZAogICAgLy8gZWFybmluZ3NfZGlzdHJpYnV0aW9uID0gc2VsZi5jb250cmFjdF9jbGFpbSgpCiAgICBjYWxsc3ViIGNvbnRyYWN0X2NsYWltCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgxOC04MTkKICAgIC8vICMgQ2hhbmdlIHN0YXRlIHRvIEVOREVEX1NVU1BFTkRFRAogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0VOREVEX1NVU1BFTkRFRCkKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgcHVzaGJ5dGVzIDB4MTUKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgyMC04MjEKICAgIC8vICMgTWFyayBlbmQgb2YgY29udHJhY3QKICAgIC8vIHNlbGYucm91bmRfZW5kZWQgPSBHbG9iYWwucm91bmQKICAgIGJ5dGVjIDggLy8gInJvdW5kX2VuZGVkIgogICAgZ2xvYmFsIFJvdW5kCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo4MjYKICAgIC8vIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODI0LTgyOAogICAgLy8gcmV0dXJuIEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZSgKICAgIC8vICAgICBlYXJuaW5nc19kaXN0cmlidXRpb249ZWFybmluZ3NfZGlzdHJpYnV0aW9uLmNvcHkoKSwKICAgIC8vICAgICBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICAvLyAgICAgbXNnPW1zZy5jb3B5KCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6ODIzCiAgICAvLyBtc2cgPSBOb3RpZmljYXRpb25NZXNzYWdlLmZyb21fYnl0ZXMoTVNHX0NPUkVfQlJFQUNIX1NVU1BFTkRFRCkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA1NDY4NjUyMDZlNjU3NDc3NmY3MjZiMjA2ODYxNzMyMDczNzU3MzcwNjU2ZTY0NjU2NDIwNzk2Zjc1NzIyMDYxNjM2MzZmNzU2ZTc0MjA2NjcyNmY2ZDIwNzM3NDYxNmI2OTZlNjcyZTIwNTk2Zjc1MjA2NDZmNmUyNzc0MjA3Mzc0NjE2YjY1MjA2MTZlNzk2ZDZmNzI2NTJlMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjgyNC04MjgKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2UoCiAgICAvLyAgICAgZWFybmluZ3NfZGlzdHJpYnV0aW9uPWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCksCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIKCgovLyBzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNvbnRyYWN0X2V4cGlyZWQoKSAtPiBieXRlczoKY29udHJhY3RfZXhwaXJlZDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6OTgwLTk4MwogICAgLy8gQGFyYzQuYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjb250cmFjdF9leHBpcmVkKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyApIC0+IEVhcm5pbmdzRGlzdHJpYnV0aW9uQW5kTWVzc2FnZToKICAgIHByb3RvIDAgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weTo5OTkKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IEdsb2JhbC5jcmVhdG9yX2FkZHJlc3MsIEVSUk9SX0NBTExFRF9CWV9OT1RfQ1JFQVRPUgogICAgdHhuIFNlbmRlcgogICAgZ2xvYmFsIENyZWF0b3JBZGRyZXNzCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGNhbGxlZCBieSBzbWFydCBjb250cmFjdCBjcmVhdG9yLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDAwCiAgICAvLyBhc3NlcnQgc2VsZi5zdGF0ZSA9PSBCeXRlcyhTVEFURV9MSVZFKSwgRVJST1JfTk9UX1NUQVRFX0xJVkUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18xIC8vICJzdGF0ZSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5zdGF0ZSBleGlzdHMKICAgIGJ5dGVjIDYgLy8gMHgwNQogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBMSVZFLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDAyCiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9lbmQgPD0gR2xvYmFsLnJvdW5kLCBFUlJPUl9OT1RfWUVUX0VYUElSRUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgZ2xvYmFsIFJvdW5kCiAgICA8PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgd2hlbiB0aGUgY29udHJhY3QgaGFzIG5vdCB5ZXQgZXhwaXJlZC4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAwNC0xMDA1CiAgICAvLyAjIENsYWltIGVhcm5pbmdzIHVwIHRvIHRoaXMgcm91bmQKICAgIC8vIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbiA9IHNlbGYuY29udHJhY3RfY2xhaW0oKQogICAgY2FsbHN1YiBjb250cmFjdF9jbGFpbQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDA2LTEwMDcKICAgIC8vICMgQ2hhbmdlIHN0YXRlIHRvIEVOREVEX0VYUElSRUQKICAgIC8vIHNlbGYuc3RhdGUgPSBCeXRlcyhTVEFURV9FTkRFRF9FWFBJUkVEKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxNAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAwOC0xMDA5CiAgICAvLyAjIE1hcmsgZW5kIG9mIGNvbnRyYWN0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxNAogICAgLy8gZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDEyLTEwMTYKICAgIC8vIHJldHVybiBFYXJuaW5nc0Rpc3RyaWJ1dGlvbkFuZE1lc3NhZ2UoCiAgICAvLyAgICAgZWFybmluZ3NfZGlzdHJpYnV0aW9uPWVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCksCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwMTEKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9DT05UUkFDVF9FWFBJUkVEKQogICAgcHVzaGJ5dGVzIDB4NGQ2NTczNzM2MTY3NjUyMDY2NzI2ZjZkMjA1NjYxNmM2MTcyM2EyMDU5NmY3NTcyMjA2MzZmNmU3NDcyNjE2Mzc0MjA3NDZmMjA3Mzc0NjE2YjY1MjA3NzY5NzQ2ODIwNjEyMDZlNmY2NDY1MjA3Mjc1NmU2ZTY1NzIyMDY4NjE3MzIwNjU2ZTY0NjU2NDJlMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAyMDIwMjAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxMi0xMDE2CiAgICAvLyByZXR1cm4gRWFybmluZ3NEaXN0cmlidXRpb25BbmRNZXNzYWdlKAogICAgLy8gICAgIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbj1lYXJuaW5nc19kaXN0cmlidXRpb24uY29weSgpLAogICAgLy8gICAgIGRlbF9tYW5hZ2VyPWFyYzQuQWRkcmVzcyhzZWxmLmRlbF9tYW5hZ2VyKSwKICAgIC8vICAgICBtc2c9bXNnLmNvcHkoKSwKICAgIC8vICkKICAgIGNvbmNhdAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLmRlbGVnYXRvcl9jb250cmFjdC5jb250cmFjdC5EZWxlZ2F0b3JDb250cmFjdC5jb250cmFjdF93aXRoZHJhdyhkZWxfbWFuYWdlcjogYnl0ZXMpIC0+IGJ5dGVzOgpjb250cmFjdF93aXRoZHJhdzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTAxOC0xMDIyCiAgICAvLyBAYXJjNC5hYmltZXRob2QoKQogICAgLy8gZGVmIGNvbnRyYWN0X3dpdGhkcmF3KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gRWFybmluZ3NEaXN0cmlidXRpb246CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0MAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNDEKICAgIC8vIGFzc2VydCBzZWxmLnN0YXRlID09IEJ5dGVzKFNUQVRFX0xJVkUpLCBFUlJPUl9OT1RfU1RBVEVfTElWRQogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzEgLy8gInN0YXRlIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnN0YXRlIGV4aXN0cwogICAgYnl0ZWMgNiAvLyAweDA1CiAgICA9PQogICAgYXNzZXJ0IC8vIENhbm5vdCBiZSBjYWxsZWQgZnJvbSBvdGhlciBzdGF0ZSB0aGFuIExJVkUuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNDMKICAgIC8vIGFzc2VydCBkZWxfbWFuYWdlciA9PSBzZWxmLmRlbF9tYW5hZ2VyLCBFUlJPUl9OT1RfTUFOQUdFUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGFwcHJvdmVkIGJ5IGRlbGVnYXRvciBtYW5hZ2VyLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDQ1CiAgICAvLyBhc3NlcnQgc2VsZi5yb3VuZF9lbmQgPiBHbG9iYWwucm91bmQsIEVSUk9SX0FMUkVBRFlfRVhQSVJFRAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzMgLy8gInJvdW5kX2VuZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5yb3VuZF9lbmQgZXhpc3RzCiAgICBnbG9iYWwgUm91bmQKICAgID4KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbnRyYWN0IGhhcyBhbHJlYWR5IGV4cGlyZWQuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwNDctMTA0OAogICAgLy8gIyBDbGFpbSBlYXJuaW5ncyB1cCB0byB0aGlzIHJvdW5kCiAgICAvLyBlYXJuaW5nc19kaXN0cmlidXRpb24gPSBzZWxmLmNvbnRyYWN0X2NsYWltKCkKICAgIGNhbGxzdWIgY29udHJhY3RfY2xhaW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA0OS0xMDUwCiAgICAvLyAjIENoYW5nZSBzdGF0ZSB0byBFTkRFRF9XSVRIRFJFVwogICAgLy8gc2VsZi5zdGF0ZSA9IEJ5dGVzKFNUQVRFX0VOREVEX1dJVEhEUkVXKQogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBwdXNoYnl0ZXMgMHgxMwogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA1MS0xMDUyCiAgICAvLyAjIE1hcmsgZW5kIG9mIGNvbnRyYWN0CiAgICAvLyBzZWxmLnJvdW5kX2VuZGVkID0gR2xvYmFsLnJvdW5kCiAgICBieXRlYyA4IC8vICJyb3VuZF9lbmRlZCIKICAgIGdsb2JhbCBSb3VuZAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA1NAogICAgLy8gcmV0dXJuIGVhcm5pbmdzX2Rpc3RyaWJ1dGlvbi5jb3B5KCkKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfZGVsZXRlKGRlbF9tYW5hZ2VyOiBieXRlcykgLT4gYnl0ZXM6CmNvbnRyYWN0X2RlbGV0ZToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA1Ni0xMDYwCiAgICAvLyBAYXJjNC5hYmltZXRob2QoYWxsb3dfYWN0aW9ucz1bIkRlbGV0ZUFwcGxpY2F0aW9uIl0pCiAgICAvLyBkZWYgY29udHJhY3RfZGVsZXRlKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgZGVsX21hbmFnZXI6IGFyYzQuQWRkcmVzcywKICAgIC8vICkgLT4gQ29udHJhY3REZWxldGVSZXR1cm46CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA4MAogICAgLy8gYXNzZXJ0IFR4bi5zZW5kZXIgPT0gR2xvYmFsLmNyZWF0b3JfYWRkcmVzcywgRVJST1JfQ0FMTEVEX0JZX05PVF9DUkVBVE9SCiAgICB0eG4gU2VuZGVyCiAgICBnbG9iYWwgQ3JlYXRvckFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gQ2FuIG9ubHkgYmUgY2FsbGVkIGJ5IHNtYXJ0IGNvbnRyYWN0IGNyZWF0b3IuCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODEKICAgIC8vIGFzc2VydCAoc2VsZi5zdGF0ZSAmIEJ5dGVzKFNUQVRFX0VOREVEX01BU0spKSA9PSBCeXRlcyhTVEFURV9FTkRFRF9NQVNLKSwgRVJST1JfTk9UX0VOREVEX1NUQVRFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyAyMSAvLyAweDEwCiAgICBiJgogICAgYnl0ZWMgMjEgLy8gMHgxMAogICAgPT0KICAgIGFzc2VydCAvLyBDYW5ub3QgYmUgY2FsbGVkIGZyb20gb3RoZXIgc3RhdGUgdGhhbiBFTkRFRF94eXouCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODMKICAgIC8vIGFzc2VydCBkZWxfbWFuYWdlciA9PSBzZWxmLmRlbF9tYW5hZ2VyLCBFUlJPUl9OT1RfTUFOQUdFUgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgZnJhbWVfZGlnIC0xCiAgICA9PQogICAgYXNzZXJ0IC8vIENhbiBvbmx5IGJlIGFwcHJvdmVkIGJ5IGRlbGVnYXRvciBtYW5hZ2VyLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg1CiAgICAvLyBhc3NldF9pZCA9IHNlbGYuZGVsZWdhdGlvbl90ZXJtc19nZW5lcmFsLnZhbHVlLmZlZV9hc3NldF9pZC5uYXRpdmUKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18wIC8vICJHIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbGVnYXRpb25fdGVybXNfZ2VuZXJhbCBleGlzdHMKICAgIGV4dHJhY3QgMjQgOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ0b2kKICAgIGR1cAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg2CiAgICAvLyBpZiBhc3NldF9pZCA9PSBVSW50NjQoQUxHT19BU0FfSUQpOgogICAgYm56IGNvbnRyYWN0X2RlbGV0ZV9lbHNlX2JvZHlAMwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg3CiAgICAvLyBiYWwgPSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLmJhbGFuY2UgLSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLm1pbl9iYWxhbmNlCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgYWNjdF9wYXJhbXNfZ2V0IEFjY3RCYWxhbmNlCiAgICBhc3NlcnQgLy8gYWNjb3VudCBmdW5kZWQKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKICAgIGFzc2VydCAvLyBhY2NvdW50IGZ1bmRlZAogICAgLQogICAgZHVwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODktMTA5MgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHJlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYW1vdW50PWJhbCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA5MAogICAgLy8gcmVjZWl2ZXI9c2VsZi5kZWxfbWFuYWdlciwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwODkKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDg5LTEwOTIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD1iYWwsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgYiBjb250cmFjdF9kZWxldGVfYWZ0ZXJfaWZfZWxzZUA1Cgpjb250cmFjdF9kZWxldGVfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjEwOTUKICAgIC8vIGJhbCA9IGFzc2V0LmJhbGFuY2UoR2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcykKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBmcmFtZV9kaWcgMAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHN3YXAKICAgIGR1cAogICAgY292ZXIgMgogICAgY292ZXIgMwogICAgYXNzZXJ0IC8vIGFjY291bnQgb3B0ZWQgaW50byBhc3NldAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDk3LTExMDIKICAgIC8vIGl0eG4uQXNzZXRUcmFuc2ZlcigKICAgIC8vICAgICB4ZmVyX2Fzc2V0PWFzc2V0LAogICAgLy8gICAgIGFzc2V0X3JlY2VpdmVyPXNlbGYuZGVsX21hbmFnZXIsCiAgICAvLyAgICAgYXNzZXRfYW1vdW50PWJhbCwKICAgIC8vICAgICBhc3NldF9jbG9zZV90bz1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9iZWdpbgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMDk5CiAgICAvLyBhc3NldF9yZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTAxCiAgICAvLyBhc3NldF9jbG9zZV90bz1zZWxmLmRlbF9tYW5hZ2VyLAogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gImRlbF9tYW5hZ2VyIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmRlbF9tYW5hZ2VyIGV4aXN0cwogICAgaXR4bl9maWVsZCBBc3NldENsb3NlVG8KICAgIGl0eG5fZmllbGQgQXNzZXRSZWNlaXZlcgogICAgaXR4bl9maWVsZCBBc3NldEFtb3VudAogICAgaXR4bl9maWVsZCBYZmVyQXNzZXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA5NwogICAgLy8gaXR4bi5Bc3NldFRyYW5zZmVyKAogICAgaW50Y18yIC8vIGF4ZmVyCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTA5Ny0xMTAyCiAgICAvLyBpdHhuLkFzc2V0VHJhbnNmZXIoCiAgICAvLyAgICAgeGZlcl9hc3NldD1hc3NldCwKICAgIC8vICAgICBhc3NldF9yZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFzc2V0X2Ftb3VudD1iYWwsCiAgICAvLyAgICAgYXNzZXRfY2xvc2VfdG89c2VsZi5kZWxfbWFuYWdlciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0Cgpjb250cmFjdF9kZWxldGVfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTA0LTExMDkKICAgIC8vICMgQ2xvc2Ugb3V0IHRoZSBhY2NvdW50IHRvIGRlbGVnYXRvciBtYW5hZ2VyCiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgcmVjZWl2ZXI9c2VsZi5kZWxfbWFuYWdlciwKICAgIC8vICAgICBhbW91bnQ9MCwKICAgIC8vICAgICBjbG9zZV9yZW1haW5kZXJfdG89c2VsZi5kZWxfbWFuYWdlciwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwNgogICAgLy8gcmVjZWl2ZXI9c2VsZi5kZWxfbWFuYWdlciwKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICJkZWxfbWFuYWdlciIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5kZWxfbWFuYWdlciBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwOAogICAgLy8gY2xvc2VfcmVtYWluZGVyX3RvPXNlbGYuZGVsX21hbmFnZXIsCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICBpdHhuX2ZpZWxkIENsb3NlUmVtYWluZGVyVG8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwNwogICAgLy8gYW1vdW50PTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBBbW91bnQKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTEwNC0xMTA1CiAgICAvLyAjIENsb3NlIG91dCB0aGUgYWNjb3VudCB0byBkZWxlZ2F0b3IgbWFuYWdlcgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18xIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExMDQtMTEwOQogICAgLy8gIyBDbG9zZSBvdXQgdGhlIGFjY291bnQgdG8gZGVsZWdhdG9yIG1hbmFnZXIKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICByZWNlaXZlcj1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gICAgIGFtb3VudD0wLAogICAgLy8gICAgIGNsb3NlX3JlbWFpbmRlcl90bz1zZWxmLmRlbF9tYW5hZ2VyLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExMgogICAgLy8gcmVtYWluaW5nX2JhbGFuY2U9YXJjNC5VSW50NjQoYmFsKSwKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExMwogICAgLy8gYXNzZXRfaWQ9YXJjNC5VSW50NjQoYXNzZXRfaWQpLAogICAgZnJhbWVfZGlnIDAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTExMS0xMTE0CiAgICAvLyByZXR1cm4gQ29udHJhY3REZWxldGVSZXR1cm4oCiAgICAvLyAgICAgcmVtYWluaW5nX2JhbGFuY2U9YXJjNC5VSW50NjQoYmFsKSwKICAgIC8vICAgICBhc3NldF9pZD1hcmM0LlVJbnQ2NChhc3NldF9pZCksCiAgICAvLyApCiAgICBjb25jYXQKICAgIHN3YXAKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5kZWxlZ2F0b3JfY29udHJhY3QuY29udHJhY3QuRGVsZWdhdG9yQ29udHJhY3QuY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKGJlZm9yZV9leHBpcnk6IHVpbnQ2NCwgcmVwb3J0X3BlcmlvZDogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uOgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTE2LTExMjEKICAgIC8vIEBhcmM0LmFiaW1ldGhvZCgpCiAgICAvLyBkZWYgY29udHJhY3RfcmVwb3J0X2V4cGlyeV9zb29uKAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgYmVmb3JlX2V4cGlyeTogVUludDY0LAogICAgLy8gICAgIHJlcG9ydF9wZXJpb2Q6IFVJbnQ2NCwKICAgIC8vICkgLT4gTWVzc2FnZToKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTQyCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBHbG9iYWwuY3JlYXRvcl9hZGRyZXNzLCBFUlJPUl9DQUxMRURfQllfTk9UX0NSRUFUT1IKICAgIHR4biBTZW5kZXIKICAgIGdsb2JhbCBDcmVhdG9yQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBDYW4gb25seSBiZSBjYWxsZWQgYnkgc21hcnQgY29udHJhY3QgY3JlYXRvci4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE0MwogICAgLy8gYXNzZXJ0IHNlbGYuc3RhdGUgPT0gQnl0ZXMoU1RBVEVfTElWRSksIEVSUk9SX05PVF9TVEFURV9MSVZFCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMSAvLyAic3RhdGUiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuc3RhdGUgZXhpc3RzCiAgICBieXRlYyA2IC8vIDB4MDUKICAgID09CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCBmcm9tIG90aGVyIHN0YXRlIHRoYW4gTElWRS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE0NQogICAgLy8gYXNzZXJ0IEdsb2JhbC5yb3VuZCArIGJlZm9yZV9leHBpcnkgPj0gc2VsZi5yb3VuZF9lbmQsIEVSUk9SX1RPT19TT09OX1RPX1JFUE9SVF9FWFBJUllfU09PTgogICAgZ2xvYmFsIFJvdW5kCiAgICBmcmFtZV9kaWcgLTIKICAgICsKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgPj0KICAgIGFzc2VydCAvLyBJdCBpcyB0b28gc29vbiB0byByZXBvcnQgdGhlIGNvbnRyYWN0IGlzIGFib3V0IHRvIGV4cGlyZS4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9kZWxlZ2F0b3JfY29udHJhY3QvY29udHJhY3QucHk6MTE0NgogICAgLy8gYXNzZXJ0IHNlbGYucm91bmRfZW5kID4gR2xvYmFsLnJvdW5kLCBFUlJPUl9BTFJFQURZX0VYUElSRUQKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18zIC8vICJyb3VuZF9lbmQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZW5kIGV4aXN0cwogICAgZ2xvYmFsIFJvdW5kCiAgICA+CiAgICBhc3NlcnQgLy8gQ2Fubm90IGJlIGNhbGxlZCB3aGVuIHRoZSBjb250cmFjdCBoYXMgYWxyZWFkeSBleHBpcmVkLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTQ4CiAgICAvLyBhc3NlcnQgR2xvYmFsLnJvdW5kID49IHNlbGYucm91bmRfZXhwaXJ5X3Nvb25fbGFzdCArIHJlcG9ydF9wZXJpb2QsIEVSUk9SX1RPT19TT09OX1RPX1JFUE9SVF9FWFBJUllfU09PTl9BR0FJTgogICAgZ2xvYmFsIFJvdW5kCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWMgMjAgLy8gInJvdW5kX2V4cGlyeV9zb29uX2xhc3QiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYucm91bmRfZXhwaXJ5X3Nvb25fbGFzdCBleGlzdHMKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgPj0KICAgIGFzc2VydCAvLyBJdCBpcyB0b28gc29vbiB0byByZXBvcnQgYWdhaW4gdGhhdCB0aGUgY29udHJhY3QgaXMgYWJvdXQgdG8gZXhwaXJlLgogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTQ5CiAgICAvLyBzZWxmLnJvdW5kX2V4cGlyeV9zb29uX2xhc3QgPSBHbG9iYWwucm91bmQKICAgIGJ5dGVjIDIwIC8vICJyb3VuZF9leHBpcnlfc29vbl9sYXN0IgogICAgZ2xvYmFsIFJvdW5kCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL2RlbGVnYXRvcl9jb250cmFjdC9jb250cmFjdC5weToxMTUzCiAgICAvLyBkZWxfbWFuYWdlcj1hcmM0LkFkZHJlc3Moc2VsZi5kZWxfbWFuYWdlciksCiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiZGVsX21hbmFnZXIiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYuZGVsX21hbmFnZXIgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExNTEKICAgIC8vIG1zZyA9IE5vdGlmaWNhdGlvbk1lc3NhZ2UuZnJvbV9ieXRlcyhNU0dfQ09SRV9XSUxMX0VYUElSRSkKICAgIHB1c2hieXRlcyAweDRkNjU3MzczNjE2NzY1MjA2NjcyNmY2ZDIwNTY2MTZjNjE3MjNhMjA1OTZmNzU3MjIwNjM2ZjZlNzQ3MjYxNjM3NDIwNzQ2ZjIwNzM3NDYxNmI2NTIwNzc2OTc0NjgyMDYxMjA2ZTZmNjQ2NTIwNzI3NTZlNmU2NTcyMjA2OTczMjA2NTc4NzA2OTcyNjk2ZTY3MmUyMDQzNmY2ZTczNjk2NDY1NzIyMDY1Nzg3NDY1NmU2NDY5NmU2NzIwNjk3NDIxMjAyMDIwCiAgICAvLyBzbWFydF9jb250cmFjdHMvZGVsZWdhdG9yX2NvbnRyYWN0L2NvbnRyYWN0LnB5OjExNTItMTE1NQogICAgLy8gcmV0dXJuIE1lc3NhZ2UoCiAgICAvLyAgICAgZGVsX21hbmFnZXI9YXJjNC5BZGRyZXNzKHNlbGYuZGVsX21hbmFnZXIpLAogICAgLy8gICAgIG1zZz1tc2cuY29weSgpLAogICAgLy8gKQogICAgY29uY2F0CiAgICByZXRzdWIK",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDExCgpzbWFydF9jb250cmFjdHMuZGVsZWdhdG9yX2NvbnRyYWN0LmNvbnRyYWN0LkRlbGVnYXRvckNvbnRyYWN0LmNsZWFyX3N0YXRlX3Byb2dyYW06CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="
  },
  "state": {
    "global": {
      "num_byte_slices": 9,
      "num_uints": 12
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "schema": {
    "global": {
      "declared": {
        "cnt_breach_del": {
          "type": "uint64",
          "key": "cnt_breach_del"
        },
        "del_beneficiary": {
          "type": "bytes",
          "key": "del_beneficiary"
        },
        "del_manager": {
          "type": "bytes",
          "key": "del_manager"
        },
        "delegation_terms_balance": {
          "type": "bytes",
          "key": "B",
          "descr": "Balance related delegation terms."
        },
        "delegation_terms_general": {
          "type": "bytes",
          "key": "G",
          "descr": "General delegation terms."
        },
        "fee_operational": {
          "type": "uint64",
          "key": "fee_operational"
        },
        "fee_operational_partner": {
          "type": "uint64",
          "key": "fee_operational_partner"
        },
        "noticeboard_app_id": {
          "type": "uint64",
          "key": "noticeboard_app_id"
        },
        "round_breach_last": {
          "type": "uint64",
          "key": "round_breach_last"
        },
        "round_claim_last": {
          "type": "uint64",
          "key": "round_claim_last"
        },
        "round_end": {
          "type": "uint64",
          "key": "round_end"
        },
        "round_ended": {
          "type": "uint64",
          "key": "round_ended"
        },
        "round_expiry_soon_last": {
          "type": "uint64",
          "key": "round_expiry_soon_last"
        },
        "round_start": {
          "type": "uint64",
          "key": "round_start"
        },
        "sel_key": {
          "type": "bytes",
          "key": "sel_key"
        },
        "state": {
          "type": "bytes",
          "key": "state"
        },
        "state_proof_key": {
          "type": "bytes",
          "key": "state_proof_key"
        },
        "tc_sha256": {
          "type": "bytes",
          "key": "tc_sha256"
        },
        "validator_ad_app_id": {
          "type": "uint64",
          "key": "validator_ad_app_id"
        },
        "vote_key": {
          "type": "bytes",
          "key": "vote_key"
        },
        "vote_key_dilution": {
          "type": "uint64",
          "key": "vote_key_dilution"
        }
      },
      "reserved": {}
    },
    "local": {
      "declared": {},
      "reserved": {}
    }
  },
  "contract": {
    "name": "DelegatorContract",
    "desc": "\n    Contract between a delegator manager and a validator (a.k.a. node runner), for the latter to participate in\n    consensus on the behalf of the delegator beneficiary for specific amount of time and for a specific fee.\n    The contract terms and conditions are defined in this contract.\n    The contract also acts as an escrow account for the delegator's payment to the validator for the service.\n\n    Global state\n    ------------\n    noticeboard_app_id : UInt64\n        App ID of noticeboard platform to which this contract belongs to.\n    validator_ad_app_id : UInt64\n        App ID of validator ad to which this contract belongs to.\n\n\n    delegation_terms_general : DelegationTermsGeneral\n        General delegation terms agreed by delegator and validator to govern this contract.\n    fee_operational : UInt64\n        Calculated operational fee based on the agreed contract terms.\n    fee_operational_partner : UInt64\n        Calculated operational fee charged for convenience by the partner.\n    delegation_terms_balance : DelegationTermsBalance\n        Requirements for delegator beneficiary balance agreed by delegator and validator to govern this contract.\n\n    del_manager : Account\n        Delegator manager account.\n    del_beneficiary : UInt64\n        Delegator beneficiary account.\n\n    round_start : UInt64\n        Agreed start round of the contract, i.e. time of its creation.\n    round_end : UInt64\n        Agreed end round of the contract.\n    round_ended : UInt64\n        Actual round at which the contract ended.\n        Can be smaller than round_end in case of early contract end.\n\n    vote_key_dilution : UInt64\n        Vote key dilution parameter of the agreed participation key.\n    vote_pk = VotePk\n        Vote public key of the agreed participation key.\n    selection_pk : SelPk\n        Selection public key of the agreed participation key.\n    state_proof_pk = StateProofPk\n        State proof public key of the agreed participation key.\n\n    state : Bytes\n        State of the contract. Can be one of the following:\n            CREATED - contract has been created.\n            LIVE - contract is live.\n            READY - waiting for keys submission.\n            SET - contract terms have been set.\n            SUBMITTED - waiting for keys confirmation.\n            ENDED_NOT_SUBMITTED - keys have not been submitted in time.\n            ENDED_NOT_CONFIRMED - keys have not been confirmed in time.\n            ENDED_LIMITS - maximum number of limit breach events has been reached.\n            ENDED_WITHDREW - delegator withdrew from the contract prematurely.\n            ENDED_EXPIRED - contract has expired.\n            ENDED_SUSPENDED - delegator has been suspended by consensus.\n            ENDED_CANNOT_PAY - delegator cannot pay the validator (as funds could have been frozen and/or clawed back).\n\n    tc_sha256 : Sha256\n        Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator\n        and validator.\n\n    cnt_breach_del : UInt64\n        Counter of limit breach events.\n    round_breach_last : UInt64\n        Number of round of last limit breach event.\n\n    round_claim_last : UInt64\n        Number of the round the operational fee was last claimed.\n\n    round_expiry_soon_last : UInt64\n        Number of the round it was last reported that the contract will expire soon.\n\n    Methods\n    -------\n    contract_create(\n        del_manager: arc4.Address,\n        del_beneficiary: arc4.Address,\n        noticeboard_app_id: UInt64,\n    ) -> Application:\n        Creates a new delegator contract and returns its app ID.\n\n    contract_setup(\n        delegation_terms_general: DelegationTermsGeneral,\n        delegation_terms_balance: DelegationTermsBalance,\n        rounds_duration: UInt64,\n    ) -> None:\n        Sets the delegation contract terms.\n\n    contract_pay(\n        txn: gtxn.Transaction,\n    ) -> None:\n        Pays the validator setup and operational fee.\n\n    keys_confirm(\n        del_manager: arc4.Address,\n    ) -> None:\n        Delegator confirms the participation keys.\n\n    keys_not_confirmed() -> Message:\n        Reports that keys have not been confirmed in time.\n\n    keys_not_submitted() -> Message:\n        Reports that keys have not been submitted in time.\n\n    keys_submit(\n        key_reg_txn_info : KeyRegTxnInfo,\n    ) -> EarningsDistributionAndMessage:\n        ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.\n\n    breach_limits(\n    ) -> BreachLimitsReturn:\n        Reports that a limit breach event occurred.\n\n    breach_pay(\n    ) -> Message:\n        Reports that a payment for the fee cannot be made from DelegatorContract (due to freeze or claw back).\n\n    breach_suspended(\n    ) -> EarningsDistributionAndMessage:\n        Reports that the delegator beneficiary was suspended by consensus.\n\n    contract_claim(\n    ) -> EarningsDistribution:\n        Claims and distributes the operational fee of validator up to this round to the validator and noticeboard,\n        as well as to the partner.\n\n    contract_expired(\n    ) -> EarningsDistributionAndMessage:\n        Reports that a contract has expired.\n\n    contract_withdraw(\n        del_manager: arc4.Address,\n    ) -> EarningsDistribution:\n        Delegator gracefully withdraws from the contract prematurely.\n\n    contract_delete(\n        del_manager: arc4.Address,\n        updating : arc4.Bool,\n    ) -> ContractDeleteReturn:\n        Delegator deletes an ended contract and withdraws any remaining balance.\n\n    contract_report_expiry_soon(\n        before_expiry: UInt64,\n        report_period: UInt64,\n    ) -> Message:\n        Reports that the contract will expire soon.\n\n    Private methods\n    ---------------\n    _distribute_earnings(\n        amount: UInt64,\n        amount_partner: UInt64,\n    ) -> EarningsDistribution:\n        Internal method for distributing the earnings between the validator ad and the noticeboard platform,\n        as well as for distributing the earnings of the partner.\n\n    _is_eligible(\n    ) -> arc4.Bool:\n        Check if del_beneficiary meets the agreed balance limits or not\n\n    _try_return_fee(\n        fee_asset: Asset,\n        amt_return: UInt64,\n    ) -> None:\n        Tries to return the input fee amount of given asset to del_manager.\n        The fee cannot be returned if the del_manager is closed out or frozen for the given asset.\n\n    ",
    "methods": [
      {
        "name": "contract_create",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Manager address for the delegation contract."
          },
          {
            "type": "address",
            "name": "del_beneficiary",
            "desc": "Beneficiary address for the delegation contract."
          },
          {
            "type": "uint64",
            "name": "noticeboard_app_id",
            "desc": "App ID of the Noticeboard smart contract to which to tie this contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "uint64",
          "desc": "App ID of the created delegation contract application."
        },
        "desc": "Creates a new DelegatorContract.\nDefines delegator contract manager and beneficiary accounts. Defines Noticeboard and ValidatorAd app ID to which this contract belongs to."
      },
      {
        "name": "contract_setup",
        "args": [
          {
            "type": "byte[32]",
            "name": "tc_sha256",
            "desc": "Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator and validator."
          },
          {
            "type": "(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64)",
            "name": "delegation_terms_general",
            "desc": "General delegation contract terms."
          },
          {
            "type": "(uint64,uint64,uint64,(uint64,uint64)[2])",
            "name": "delegation_terms_balance",
            "desc": "Balance delegation contract terms."
          },
          {
            "type": "uint64",
            "name": "rounds_duration",
            "desc": "Contract duration in number of rounds."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Sets the general and balance delegation contract terms.\nDefines contract start and end rounds. Opts in the payment asset if it is not ALGO."
      },
      {
        "name": "contract_pay",
        "args": [
          {
            "type": "txn",
            "name": "txn",
            "desc": "Transaction for the payment of the setup and operational fees."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Pays the validator setup and operational fee."
      },
      {
        "name": "keys_confirm",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Purported delegator manager account."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "void"
        },
        "desc": "Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys.."
      },
      {
        "name": "keys_not_confirmed",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that keys have not been confirmed in time."
      },
      {
        "name": "keys_not_submitted",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that keys have not been submitted in time."
      },
      {
        "name": "keys_submit",
        "args": [
          {
            "type": "(uint64,uint64,uint64,byte[32],byte[32],byte[64],address)",
            "name": "key_reg_txn_info",
            "desc": "Information about the generated participation keys."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "((uint64,uint64,uint64),address,byte[100])",
          "desc": "Amount of earnings of the validator which equal the setup fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
        },
        "desc": "ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms."
      },
      {
        "name": "breach_limits",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "(bool,(uint64,uint64,uint64),address,byte[100])",
          "desc": "Boolean denoting if maximum number of breaches has already been reached (True) or not (False)."
        },
        "desc": "Reports that a limit breach event occurred."
      },
      {
        "name": "breach_pay",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that a payment for the fee cannot be made from DelegatorContract.\nThis can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager."
      },
      {
        "name": "breach_suspended",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "((uint64,uint64,uint64),address,byte[100])",
          "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
        },
        "desc": "Reports that the delegator beneficiary was suspended by consensus."
      },
      {
        "name": "contract_claim",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "(uint64,uint64,uint64)",
          "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
        },
        "desc": "Claims operational fee of validator up to this round.\nCommission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner."
      },
      {
        "name": "contract_expired",
        "args": [],
        "readonly": false,
        "returns": {
          "type": "((uint64,uint64,uint64),address,byte[100])",
          "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
        },
        "desc": "Reports that a contract has expired."
      },
      {
        "name": "contract_withdraw",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Manager address for the delegation contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(uint64,uint64,uint64)",
          "desc": "Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted."
        },
        "desc": "Delegator gracefully withdraws from the contract prematurely.\nThe delegator beneficiary should issue a key deregistration transaction 320 round before this call."
      },
      {
        "name": "contract_delete",
        "args": [
          {
            "type": "address",
            "name": "del_manager",
            "desc": "Manager address for the delegation contract."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(uint64,uint64)",
          "desc": "Balance of the fee asset that remained in the contract."
        },
        "desc": "Delegator deletes an ended contract and withdraws any remaining balance.\nThere can be non-zero balance to withdraw if someone sent the contract some balance, or if it was not possible to claim the fee by validator and/or noticeboard if they had the asset frozen."
      },
      {
        "name": "contract_report_expiry_soon",
        "args": [
          {
            "type": "uint64",
            "name": "before_expiry",
            "desc": "How many rounds before contract end can the report be made."
          },
          {
            "type": "uint64",
            "name": "report_period",
            "desc": "How frequently can the report be made."
          }
        ],
        "readonly": false,
        "returns": {
          "type": "(address,byte[100])",
          "desc": "Address of delegator manager."
        },
        "desc": "Reports that the contract will expire soon.\nNotification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming."
      }
    ],
    "networks": {}
  },
  "bare_call_config": {}
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

export type IncludeSchema = {
  /**
   * Any overrides for the storage schema to request for the created app; by default the schema indicated by the app spec is used.
   */
  schema?: Partial<AppStorageSchema>
}

/**
 * Defines the types of available calls and state of the DelegatorContract smart contract.
 */
export type DelegatorContract = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'contract_create(address,address,uint64)uint64' | 'contract_create', {
      argsObj: {
        /**
         * Manager address for the delegation contract.
         */
        delManager: string
        /**
         * Beneficiary address for the delegation contract.
         */
        delBeneficiary: string
        /**
         * App ID of the Noticeboard smart contract to which to tie this contract.
         */
        noticeboardAppId: bigint | number
      }
      argsTuple: [delManager: string, delBeneficiary: string, noticeboardAppId: bigint | number]
      /**
       * App ID of the created delegation contract application.
       */
      returns: bigint
    }>
    & Record<'contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void' | 'contract_setup', {
      argsObj: {
        /**
         * Hash (i.e. SHA 256) of the Terms and Conditions defining the delegation contract concluded between the delegator and validator.
         */
        tcSha256: Uint8Array
        /**
         * General delegation contract terms.
         */
        delegationTermsGeneral: [bigint | number, bigint | number, bigint | number, bigint | number, string, bigint | number, bigint | number, bigint | number, bigint | number]
        /**
         * Balance delegation contract terms.
         */
        delegationTermsBalance: [bigint | number, bigint | number, bigint | number, [[bigint | number, bigint | number], [bigint | number, bigint | number]]]
        /**
         * Contract duration in number of rounds.
         */
        roundsDuration: bigint | number
      }
      argsTuple: [tcSha256: Uint8Array, delegationTermsGeneral: [bigint | number, bigint | number, bigint | number, bigint | number, string, bigint | number, bigint | number, bigint | number, bigint | number], delegationTermsBalance: [bigint | number, bigint | number, bigint | number, [[bigint | number, bigint | number], [bigint | number, bigint | number]]], roundsDuration: bigint | number]
      returns: void
    }>
    & Record<'contract_pay(txn)void' | 'contract_pay', {
      argsObj: {
        /**
         * Transaction for the payment of the setup and operational fees.
         */
        txn: TransactionToSign | Transaction | Promise<SendTransactionResult>
      }
      argsTuple: [txn: TransactionToSign | Transaction | Promise<SendTransactionResult>]
      returns: void
    }>
    & Record<'keys_confirm(address)void' | 'keys_confirm', {
      argsObj: {
        /**
         * Purported delegator manager account.
         */
        delManager: string
      }
      argsTuple: [delManager: string]
      returns: void
    }>
    & Record<'keys_not_confirmed()(address,byte[100])' | 'keys_not_confirmed', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'keys_not_submitted()(address,byte[100])' | 'keys_not_submitted', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])' | 'keys_submit', {
      argsObj: {
        /**
         * Information about the generated participation keys.
         */
        keyRegTxnInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string]
      }
      argsTuple: [keyRegTxnInfo: [bigint | number, bigint | number, bigint | number, Uint8Array, Uint8Array, Uint8Array, string]]
      /**
       * Amount of earnings of the validator which equal the setup fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
       */
      returns: EarningsDistributionAndMessage
    }>
    & Record<'breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])' | 'breach_limits', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Boolean denoting if maximum number of breaches has already been reached (True) or not (False).
       */
      returns: BreachLimitsReturn
    }>
    & Record<'breach_pay()(address,byte[100])' | 'breach_pay', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
    & Record<'breach_suspended()((uint64,uint64,uint64),address,byte[100])' | 'breach_suspended', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
       */
      returns: EarningsDistributionAndMessage
    }>
    & Record<'contract_claim()(uint64,uint64,uint64)' | 'contract_claim', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
       */
      returns: EarningsDistribution
    }>
    & Record<'contract_expired()((uint64,uint64,uint64),address,byte[100])' | 'contract_expired', {
      argsObj: {
      }
      argsTuple: []
      /**
       * Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
       */
      returns: EarningsDistributionAndMessage
    }>
    & Record<'contract_withdraw(address)(uint64,uint64,uint64)' | 'contract_withdraw', {
      argsObj: {
        /**
         * Manager address for the delegation contract.
         */
        delManager: string
      }
      argsTuple: [delManager: string]
      /**
       * Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
       */
      returns: EarningsDistribution
    }>
    & Record<'contract_delete(address)(uint64,uint64)' | 'contract_delete', {
      argsObj: {
        /**
         * Manager address for the delegation contract.
         */
        delManager: string
      }
      argsTuple: [delManager: string]
      /**
       * Balance of the fee asset that remained in the contract.
       */
      returns: ContractDeleteReturn
    }>
    & Record<'contract_report_expiry_soon(uint64,uint64)(address,byte[100])' | 'contract_report_expiry_soon', {
      argsObj: {
        /**
         * How many rounds before contract end can the report be made.
         */
        beforeExpiry: bigint | number
        /**
         * How frequently can the report be made.
         */
        reportPeriod: bigint | number
      }
      argsTuple: [beforeExpiry: bigint | number, reportPeriod: bigint | number]
      /**
       * Address of delegator manager.
       */
      returns: Message
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      cntBreachDel?: IntegerState
      delBeneficiary?: BinaryState
      delManager?: BinaryState
      /**
       * Balance related delegation terms.
       */
      b?: BinaryState
      /**
       * General delegation terms.
       */
      g?: BinaryState
      feeOperational?: IntegerState
      feeOperationalPartner?: IntegerState
      noticeboardAppId?: IntegerState
      roundBreachLast?: IntegerState
      roundClaimLast?: IntegerState
      roundEnd?: IntegerState
      roundEnded?: IntegerState
      roundExpirySoonLast?: IntegerState
      roundStart?: IntegerState
      selKey?: BinaryState
      state?: BinaryState
      stateProofKey?: BinaryState
      tcSha256?: BinaryState
      validatorAdAppId?: IntegerState
      voteKey?: BinaryState
      voteKeyDilution?: IntegerState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type DelegatorContractSig = keyof DelegatorContract['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends DelegatorContractSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Represents a DelegationTermsGeneral result as a struct
 */
export type DelegationTermsGeneral = {
  commission: bigint
  feeRound: bigint
  feeSetup: bigint
  feeAssetId: bigint
  partnerAddress: string
  feeRoundPartner: bigint
  feeSetupPartner: bigint
  roundsSetup: bigint
  roundsConfirm: bigint
}
/**
 * Converts the tuple representation of a DelegationTermsGeneral to the struct representation
 */
export function DelegationTermsGeneral([commission, feeRound, feeSetup, feeAssetId, partnerAddress, feeRoundPartner, feeSetupPartner, roundsSetup, roundsConfirm]: [bigint, bigint, bigint, bigint, string, bigint, bigint, bigint, bigint] ) {
  return {
    commission,
    feeRound,
    feeSetup,
    feeAssetId,
    partnerAddress,
    feeRoundPartner,
    feeSetupPartner,
    roundsSetup,
    roundsConfirm,
  }
}
/**
 * Represents a DelegationTermsBalance result as a struct
 */
export type DelegationTermsBalance = {
  stakeMax: bigint
  cntBreachDelMax: bigint
  roundsBreach: bigint
  gatingAsaList: [[bigint, bigint], [bigint, bigint]]
}
/**
 * Converts the tuple representation of a DelegationTermsBalance to the struct representation
 */
export function DelegationTermsBalance([stakeMax, cntBreachDelMax, roundsBreach, gatingAsaList]: [bigint, bigint, bigint, [[bigint, bigint], [bigint, bigint]]] ) {
  return {
    stakeMax,
    cntBreachDelMax,
    roundsBreach,
    gatingAsaList,
  }
}
/**
 * Represents a Message result as a struct
 */
export type Message = {
  delManager: string
  msg: Uint8Array
}
/**
 * Converts the tuple representation of a Message to the struct representation
 */
export function Message([delManager, msg]: [string, Uint8Array] ) {
  return {
    delManager,
    msg,
  }
}
/**
 * Represents a KeyRegTxnInfo result as a struct
 */
export type KeyRegTxnInfo = {
  voteFirst: bigint
  voteLast: bigint
  voteKeyDilution: bigint
  votePk: Uint8Array
  selectionPk: Uint8Array
  stateProofPk: Uint8Array
  sender: string
}
/**
 * Converts the tuple representation of a KeyRegTxnInfo to the struct representation
 */
export function KeyRegTxnInfo([voteFirst, voteLast, voteKeyDilution, votePk, selectionPk, stateProofPk, sender]: [bigint, bigint, bigint, Uint8Array, Uint8Array, Uint8Array, string] ) {
  return {
    voteFirst,
    voteLast,
    voteKeyDilution,
    votePk,
    selectionPk,
    stateProofPk,
    sender,
  }
}
/**
 * Represents a EarningsDistributionAndMessage result as a struct
 */
export type EarningsDistributionAndMessage = {
  earningsDistribution: [bigint, bigint, bigint]
  delManager: string
  msg: Uint8Array
}
/**
 * Converts the tuple representation of a EarningsDistributionAndMessage to the struct representation
 */
export function EarningsDistributionAndMessage([earningsDistribution, delManager, msg]: [[bigint, bigint, bigint], string, Uint8Array] ) {
  return {
    earningsDistribution,
    delManager,
    msg,
  }
}
/**
 * Represents a BreachLimitsReturn result as a struct
 */
export type BreachLimitsReturn = {
  maxBreachReached: boolean
  earningsDistribution: [bigint, bigint, bigint]
  delManager: string
  msg: Uint8Array
}
/**
 * Converts the tuple representation of a BreachLimitsReturn to the struct representation
 */
export function BreachLimitsReturn([maxBreachReached, earningsDistribution, delManager, msg]: [boolean, [bigint, bigint, bigint], string, Uint8Array] ) {
  return {
    maxBreachReached,
    earningsDistribution,
    delManager,
    msg,
  }
}
/**
 * Represents a EarningsDistribution result as a struct
 */
export type EarningsDistribution = {
  user: bigint
  platform: bigint
  assetId: bigint
}
/**
 * Converts the tuple representation of a EarningsDistribution to the struct representation
 */
export function EarningsDistribution([user, platform, assetId]: [bigint, bigint, bigint] ) {
  return {
    user,
    platform,
    assetId,
  }
}
/**
 * Represents a ContractDeleteReturn result as a struct
 */
export type ContractDeleteReturn = {
  remainingBalance: bigint
  assetId: bigint
}
/**
 * Converts the tuple representation of a ContractDeleteReturn to the struct representation
 */
export function ContractDeleteReturn([remainingBalance, assetId]: [bigint, bigint] ) {
  return {
    remainingBalance,
    assetId,
  }
}
/**
 * Maps a method signature from the DelegatorContract smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends DelegatorContractSig> = DelegatorContract['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the DelegatorContract smart contract to the method's return type
 */
export type MethodReturn<TSignature extends DelegatorContractSig> = DelegatorContract['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type DelegatorContractCreateCalls = (typeof DelegatorContractCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type DelegatorContractCreateCallParams =
  | (TypedCallParams<'contract_create(address,address,uint64)uint64'> & (OnCompleteNoOp))
/**
 * A factory for available 'delete' calls
 */
export type DelegatorContractDeleteCalls = (typeof DelegatorContractCallFactory)['delete']
/**
 * Defines supported delete methods for this smart contract
 */
export type DelegatorContractDeleteCallParams =
  | TypedCallParams<'contract_delete(address)(uint64,uint64)'>
/**
 * Defines arguments required for the deploy method.
 */
export type DelegatorContractDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: DelegatorContractCreateCalls) => DelegatorContractCreateCallParams
  /**
   * A delegate which takes a delete call factory and returns the delete call params for this smart contract
   */
  deleteCall?: (callFactory: DelegatorContractDeleteCalls) => DelegatorContractDeleteCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class DelegatorContractCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the DelegatorContract smart contract using the contract_create(address,address,uint64)uint64 ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      contractCreate(args: MethodArgs<'contract_create(address,address,uint64)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'contract_create(address,address,uint64)uint64' as const,
          methodArgs: Array.isArray(args) ? args : [args.delManager, args.delBeneficiary, args.noticeboardAppId],
          ...params,
        }
      },
    }
  }

  /**
   * Gets available delete call factories
   */
  static get delete() {
    return {
      /**
       * Constructs a delete call for the DelegatorContract smart contract using the contract_delete(address)(uint64,uint64) ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      contractDelete(args: MethodArgs<'contract_delete(address)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return {
          method: 'contract_delete(address)(uint64,uint64)' as const,
          methodArgs: Array.isArray(args) ? args : [args.delManager],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void ABI method
   *
   * Sets the general and balance delegation contract terms.
Defines contract start and end rounds. Opts in the payment asset if it is not ALGO.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractSetup(args: MethodArgs<'contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.tcSha256, args.delegationTermsGeneral, args.delegationTermsBalance, args.roundsDuration],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_pay(txn)void ABI method
   *
   * Pays the validator setup and operational fee.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractPay(args: MethodArgs<'contract_pay(txn)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_pay(txn)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.txn],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_confirm(address)void ABI method
   *
   * Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys..
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysConfirm(args: MethodArgs<'keys_confirm(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_confirm(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.delManager],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_not_confirmed()(address,byte[100]) ABI method
   *
   * Reports that keys have not been confirmed in time.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysNotConfirmed(args: MethodArgs<'keys_not_confirmed()(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_not_confirmed()(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_not_submitted()(address,byte[100]) ABI method
   *
   * Reports that keys have not been submitted in time.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysNotSubmitted(args: MethodArgs<'keys_not_submitted()(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_not_submitted()(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100]) ABI method
   *
   * ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static keysSubmit(args: MethodArgs<'keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.keyRegTxnInfo],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the breach_limits()(bool,(uint64,uint64,uint64),address,byte[100]) ABI method
   *
   * Reports that a limit breach event occurred.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static breachLimits(args: MethodArgs<'breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the breach_pay()(address,byte[100]) ABI method
   *
   * Reports that a payment for the fee cannot be made from DelegatorContract.
This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static breachPay(args: MethodArgs<'breach_pay()(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'breach_pay()(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the breach_suspended()((uint64,uint64,uint64),address,byte[100]) ABI method
   *
   * Reports that the delegator beneficiary was suspended by consensus.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static breachSuspended(args: MethodArgs<'breach_suspended()((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'breach_suspended()((uint64,uint64,uint64),address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_claim()(uint64,uint64,uint64) ABI method
   *
   * Claims operational fee of validator up to this round.
Commission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractClaim(args: MethodArgs<'contract_claim()(uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_claim()(uint64,uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_expired()((uint64,uint64,uint64),address,byte[100]) ABI method
   *
   * Reports that a contract has expired.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractExpired(args: MethodArgs<'contract_expired()((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_expired()((uint64,uint64,uint64),address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_withdraw(address)(uint64,uint64,uint64) ABI method
   *
   * Delegator gracefully withdraws from the contract prematurely.
The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractWithdraw(args: MethodArgs<'contract_withdraw(address)(uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_withdraw(address)(uint64,uint64,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args.delManager],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the contract_report_expiry_soon(uint64,uint64)(address,byte[100]) ABI method
   *
   * Reports that the contract will expire soon.
Notification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'contract_report_expiry_soon(uint64,uint64)(address,byte[100])' as const,
      methodArgs: Array.isArray(args) ? args : [args.beforeExpiry, args.reportPeriod],
      ...params,
    }
  }
}

/**
 * A client to make calls to the DelegatorContract smart contract
 */
export class DelegatorContractClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `DelegatorContractClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof DelegatorContract['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the DelegatorContract smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: DelegatorContractDeployArgs & AppClientDeployCoreParams & IncludeSchema = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(DelegatorContractCallFactory.create)
    const deleteArgs = params.deleteCall?.(DelegatorContractCallFactory.delete)
    return this.appClient.deploy({
      ...params,
      deleteArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the DelegatorContract smart contract using the contract_create(address,address,uint64)uint64 ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result: App ID of the created delegation contract application.
       */
      async contractCreate(args: MethodArgs<'contract_create(address,address,uint64)uint64'>, params: AppClientCallCoreParams & AppClientCompilationParams & IncludeSchema & CoreAppCallArgs & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'contract_create(address,address,uint64)uint64'>, AppCreateCallTransactionResult>(await $this.appClient.create(DelegatorContractCallFactory.create.contractCreate(args, params)))
      },
    }
  }

  /**
   * Gets available delete methods
   */
  public get delete() {
    const $this = this
    return {
      /**
       * Deletes an existing instance of the DelegatorContract smart contract using the contract_delete(address)(uint64,uint64) ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The delete result: Balance of the fee asset that remained in the contract.
       */
      async contractDelete(args: MethodArgs<'contract_delete(address)(uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
        return $this.mapReturnValue<MethodReturn<'contract_delete(address)(uint64,uint64)'>>(await $this.appClient.delete(DelegatorContractCallFactory.delete.contractDelete(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the DelegatorContract smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void ABI method.
   *
   * Sets the general and balance delegation contract terms.
Defines contract start and end rounds. Opts in the payment asset if it is not ALGO.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public contractSetup(args: MethodArgs<'contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.contractSetup(args, params))
  }

  /**
   * Calls the contract_pay(txn)void ABI method.
   *
   * Pays the validator setup and operational fee.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public contractPay(args: MethodArgs<'contract_pay(txn)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.contractPay(args, params))
  }

  /**
   * Calls the keys_confirm(address)void ABI method.
   *
   * Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys..
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public keysConfirm(args: MethodArgs<'keys_confirm(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.keysConfirm(args, params))
  }

  /**
   * Calls the keys_not_confirmed()(address,byte[100]) ABI method.
   *
   * Reports that keys have not been confirmed in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public keysNotConfirmed(args: MethodArgs<'keys_not_confirmed()(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.keysNotConfirmed(args, params), Message)
  }

  /**
   * Calls the keys_not_submitted()(address,byte[100]) ABI method.
   *
   * Reports that keys have not been submitted in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public keysNotSubmitted(args: MethodArgs<'keys_not_submitted()(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.keysNotSubmitted(args, params), Message)
  }

  /**
   * Calls the keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of earnings of the validator which equal the setup fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
   */
  public keysSubmit(args: MethodArgs<'keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.keysSubmit(args, params), EarningsDistributionAndMessage)
  }

  /**
   * Calls the breach_limits()(bool,(uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that a limit breach event occurred.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Boolean denoting if maximum number of breaches has already been reached (True) or not (False).
   */
  public breachLimits(args: MethodArgs<'breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.breachLimits(args, params), BreachLimitsReturn)
  }

  /**
   * Calls the breach_pay()(address,byte[100]) ABI method.
   *
   * Reports that a payment for the fee cannot be made from DelegatorContract.
This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public breachPay(args: MethodArgs<'breach_pay()(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.breachPay(args, params), Message)
  }

  /**
   * Calls the breach_suspended()((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that the delegator beneficiary was suspended by consensus.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
   */
  public breachSuspended(args: MethodArgs<'breach_suspended()((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.breachSuspended(args, params), EarningsDistributionAndMessage)
  }

  /**
   * Calls the contract_claim()(uint64,uint64,uint64) ABI method.
   *
   * Claims operational fee of validator up to this round.
Commission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
   */
  public contractClaim(args: MethodArgs<'contract_claim()(uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.contractClaim(args, params), EarningsDistribution)
  }

  /**
   * Calls the contract_expired()((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that a contract has expired.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
   */
  public contractExpired(args: MethodArgs<'contract_expired()((uint64,uint64,uint64),address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.contractExpired(args, params), EarningsDistributionAndMessage)
  }

  /**
   * Calls the contract_withdraw(address)(uint64,uint64,uint64) ABI method.
   *
   * Delegator gracefully withdraws from the contract prematurely.
The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Amount of earnings of the validator which equal any unclaimed operational fee minus platform commission, amount of platform earnings from the commission, and the asset in which the earnings are denoted.
   */
  public contractWithdraw(args: MethodArgs<'contract_withdraw(address)(uint64,uint64,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.contractWithdraw(args, params), EarningsDistribution)
  }

  /**
   * Calls the contract_report_expiry_soon(uint64,uint64)(address,byte[100]) ABI method.
   *
   * Reports that the contract will expire soon.
Notification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call: Address of delegator manager.
   */
  public contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64)(address,byte[100])'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DelegatorContractCallFactory.contractReportExpirySoon(args, params), Message)
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<DelegatorContract['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get cntBreachDel() {
        return DelegatorContractClient.getIntegerState(state, 'cnt_breach_del')
      },
      get delBeneficiary() {
        return DelegatorContractClient.getBinaryState(state, 'del_beneficiary')
      },
      get delManager() {
        return DelegatorContractClient.getBinaryState(state, 'del_manager')
      },
      get b() {
        return DelegatorContractClient.getBinaryState(state, 'B')
      },
      get g() {
        return DelegatorContractClient.getBinaryState(state, 'G')
      },
      get feeOperational() {
        return DelegatorContractClient.getIntegerState(state, 'fee_operational')
      },
      get feeOperationalPartner() {
        return DelegatorContractClient.getIntegerState(state, 'fee_operational_partner')
      },
      get noticeboardAppId() {
        return DelegatorContractClient.getIntegerState(state, 'noticeboard_app_id')
      },
      get roundBreachLast() {
        return DelegatorContractClient.getIntegerState(state, 'round_breach_last')
      },
      get roundClaimLast() {
        return DelegatorContractClient.getIntegerState(state, 'round_claim_last')
      },
      get roundEnd() {
        return DelegatorContractClient.getIntegerState(state, 'round_end')
      },
      get roundEnded() {
        return DelegatorContractClient.getIntegerState(state, 'round_ended')
      },
      get roundExpirySoonLast() {
        return DelegatorContractClient.getIntegerState(state, 'round_expiry_soon_last')
      },
      get roundStart() {
        return DelegatorContractClient.getIntegerState(state, 'round_start')
      },
      get selKey() {
        return DelegatorContractClient.getBinaryState(state, 'sel_key')
      },
      get state() {
        return DelegatorContractClient.getBinaryState(state, 'state')
      },
      get stateProofKey() {
        return DelegatorContractClient.getBinaryState(state, 'state_proof_key')
      },
      get tcSha256() {
        return DelegatorContractClient.getBinaryState(state, 'tc_sha256')
      },
      get validatorAdAppId() {
        return DelegatorContractClient.getIntegerState(state, 'validator_ad_app_id')
      },
      get voteKey() {
        return DelegatorContractClient.getBinaryState(state, 'vote_key')
      },
      get voteKeyDilution() {
        return DelegatorContractClient.getIntegerState(state, 'vote_key_dilution')
      },
    }
  }

  public compose(): DelegatorContractComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      contractSetup(args: MethodArgs<'contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractSetup(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      contractPay(args: MethodArgs<'contract_pay(txn)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractPay(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      keysConfirm(args: MethodArgs<'keys_confirm(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysConfirm(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      keysNotConfirmed(args: MethodArgs<'keys_not_confirmed()(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysNotConfirmed(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      keysNotSubmitted(args: MethodArgs<'keys_not_submitted()(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysNotSubmitted(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      keysSubmit(args: MethodArgs<'keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.keysSubmit(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(EarningsDistributionAndMessage)
        return this
      },
      breachLimits(args: MethodArgs<'breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.breachLimits(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(BreachLimitsReturn)
        return this
      },
      breachPay(args: MethodArgs<'breach_pay()(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.breachPay(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      breachSuspended(args: MethodArgs<'breach_suspended()((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.breachSuspended(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(EarningsDistributionAndMessage)
        return this
      },
      contractClaim(args: MethodArgs<'contract_claim()(uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractClaim(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(EarningsDistribution)
        return this
      },
      contractExpired(args: MethodArgs<'contract_expired()((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractExpired(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(EarningsDistributionAndMessage)
        return this
      },
      contractWithdraw(args: MethodArgs<'contract_withdraw(address)(uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractWithdraw(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(EarningsDistribution)
        return this
      },
      contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.contractReportExpirySoon(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(Message)
        return this
      },
      get delete() {
        const $this = this
        return {
          contractDelete(args: MethodArgs<'contract_delete(address)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams) {
            promiseChain = promiseChain.then(() => client.delete.contractDelete(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
            resultMappers.push(ContractDeleteReturn)
            return $this
          },
        }
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as DelegatorContractComposer
  }
}
export type DelegatorContractComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void ABI method.
   *
   * Sets the general and balance delegation contract terms.
Defines contract start and end rounds. Opts in the payment asset if it is not ALGO.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractSetup(args: MethodArgs<'contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'contract_setup(byte[32],(uint64,uint64,uint64,uint64,address,uint64,uint64,uint64,uint64),(uint64,uint64,uint64,(uint64,uint64)[2]),uint64)void'>]>

  /**
   * Calls the contract_pay(txn)void ABI method.
   *
   * Pays the validator setup and operational fee.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractPay(args: MethodArgs<'contract_pay(txn)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'contract_pay(txn)void'>]>

  /**
   * Calls the keys_confirm(address)void ABI method.
   *
   * Delegator manager confirms that the delegator beneficiary has confirmed the submitted keys..
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysConfirm(args: MethodArgs<'keys_confirm(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'keys_confirm(address)void'>]>

  /**
   * Calls the keys_not_confirmed()(address,byte[100]) ABI method.
   *
   * Reports that keys have not been confirmed in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysNotConfirmed(args: MethodArgs<'keys_not_confirmed()(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'keys_not_confirmed()(address,byte[100])'>]>

  /**
   * Calls the keys_not_submitted()(address,byte[100]) ABI method.
   *
   * Reports that keys have not been submitted in time.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysNotSubmitted(args: MethodArgs<'keys_not_submitted()(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'keys_not_submitted()(address,byte[100])'>]>

  /**
   * Calls the keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * ValidatorAd submits the keys generated for the delegator beneficiary according to the contract terms.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  keysSubmit(args: MethodArgs<'keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'keys_submit((uint64,uint64,uint64,byte[32],byte[32],byte[64],address))((uint64,uint64,uint64),address,byte[100])'>]>

  /**
   * Calls the breach_limits()(bool,(uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that a limit breach event occurred.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  breachLimits(args: MethodArgs<'breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'breach_limits()(bool,(uint64,uint64,uint64),address,byte[100])'>]>

  /**
   * Calls the breach_pay()(address,byte[100]) ABI method.
   *
   * Reports that a payment for the fee cannot be made from DelegatorContract.
This can happen if the DelegatorContract payment asset has been frozen or clawed back by the asset manager.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  breachPay(args: MethodArgs<'breach_pay()(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'breach_pay()(address,byte[100])'>]>

  /**
   * Calls the breach_suspended()((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that the delegator beneficiary was suspended by consensus.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  breachSuspended(args: MethodArgs<'breach_suspended()((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'breach_suspended()((uint64,uint64,uint64),address,byte[100])'>]>

  /**
   * Calls the contract_claim()(uint64,uint64,uint64) ABI method.
   *
   * Claims operational fee of validator up to this round.
Commission from the fee gets claimed by the noticeboard. Partner convenience fee gets claimed by the partner.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractClaim(args: MethodArgs<'contract_claim()(uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'contract_claim()(uint64,uint64,uint64)'>]>

  /**
   * Calls the contract_expired()((uint64,uint64,uint64),address,byte[100]) ABI method.
   *
   * Reports that a contract has expired.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractExpired(args: MethodArgs<'contract_expired()((uint64,uint64,uint64),address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'contract_expired()((uint64,uint64,uint64),address,byte[100])'>]>

  /**
   * Calls the contract_withdraw(address)(uint64,uint64,uint64) ABI method.
   *
   * Delegator gracefully withdraws from the contract prematurely.
The delegator beneficiary should issue a key deregistration transaction 320 round before this call.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractWithdraw(args: MethodArgs<'contract_withdraw(address)(uint64,uint64,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'contract_withdraw(address)(uint64,uint64,uint64)'>]>

  /**
   * Calls the contract_report_expiry_soon(uint64,uint64)(address,byte[100]) ABI method.
   *
   * Reports that the contract will expire soon.
Notification message can be triggered only a pre-defined time in advance and with limited frequency to prevent spamming.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  contractReportExpirySoon(args: MethodArgs<'contract_report_expiry_soon(uint64,uint64)(address,byte[100])'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, MethodReturn<'contract_report_expiry_soon(uint64,uint64)(address,byte[100])'>]>

  /**
   * Gets available delete methods
   */
  readonly delete: {
    /**
     * Deletes an existing instance of the DelegatorContract smart contract using the contract_delete(address)(uint64,uint64) ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    contractDelete(args: MethodArgs<'contract_delete(address)(uint64,uint64)'>, params?: AppClientComposeCallCoreParams): DelegatorContractComposer<[...TReturns, MethodReturn<'contract_delete(address)(uint64,uint64)'>]>
  }

  /**
   * Makes a clear_state call to an existing instance of the DelegatorContract smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): DelegatorContractComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): DelegatorContractComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<DelegatorContractComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<DelegatorContractComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type DelegatorContractComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type DelegatorContractComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
